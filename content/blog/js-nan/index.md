---
title: (ë²ˆì—­) ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œ `NaN !== NaN`ì¸ ì´ìœ  (ê·¸ë¦¬ê³  ê·¸ ë’¤ì— ìˆ¨ì€ IEEE 754 ì´ì•¼ê¸°)
description:
date: 2025-11-16
lastUpdated: 2025-11-16
tags: [ë²ˆì—­]
---

> ì›ë¬¸: [Why NaN !== NaN in JavaScript (and the IEEE 754 story behind it)](https://pzarycki.com/en/posts/js-nan/)

![](https://pzarycki.com/en/posts/js-nan/nan.en.png)

## í•­ìƒ ê°™ì€ ê²ƒì„ ë°˜í™˜í•˜ëŠ” ìˆ«ì

ì˜¤ëŠ˜ ìš°ë¦¬ëŠ” ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œ `number` íƒ€ì…ìœ¼ë¡œ ì‹ë³„ë˜ëŠ” `NaN`ì— ëŒ€í•´ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

```js
> typeof NaN
'number'
```

ì‘ë‹µìœ¼ë¡œ `number` íƒ€ì…ì„ ë°›ìŠµë‹ˆë‹¤.
ë¬´ì—‡ì¸ê°€ ìˆ«ìì´ë ¤ë©´, ë…¼ë¦¬ì ìœ¼ë¡œ ìˆ˜í•™ ì—°ì‚°ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
ê·¸ëŸ¬ë‹ˆ `NaN`ì— ë‹¤ë¥¸ ë¬´ì–¸ê°€ë¥¼ ë”í•˜ê±°ë‚˜ ìµœëŒ“ê°’, ìµœì†Ÿê°’ì„ í™•ì¸í•´ ë³´ê² ìŠµë‹ˆë‹¤.

```js
> NaN + 1
NaN
> NaN - 1
NaN
> Math.max(NaN)
NaN
> Math.min(NaN)
NaN
```

ë³´ì‹œë‹¤ì‹œí”¼, ë§ì…ˆ, ëº„ì…ˆ, ìµœëŒ“ê°’/ìµœì†Ÿê°’ í™•ì¸ í›„ì—ë„ í•­ìƒ ê°™ì€ ê²°ê³¼ë¥¼ ì–»ìŠµë‹ˆë‹¤.
ê·¸ë ‡ë‹¤ë©´ ì™œ ì´ëŸ° ê°’ì´ í•„ìš”í•œ ê±¸ê¹Œìš”?
ì´ë¥¼ ì„¤ëª…í•˜ê¸° ìœ„í•´, Firefoxë‚˜ V8 ë‚´ë¶€ë¥¼ ë“¤ì—¬ë‹¤ë³´ë©° `NaN`ì˜ ì‚¬ìš©ì²˜ì™€ êµ¬í˜„ì„ ì°¾ì•„ë³´ê² ìŠµë‹ˆë‹¤.

```cpp
// Firefox
bool isNaN() const { return isDouble() && std::isnan(toDouble()); }

// V8
if (IsMinusZero(value)) return has_minus_zero();
if (std::isnan(value)) return has_nan();
```

ì˜ˆì‹œ ë¸Œë¼ìš°ì €ì˜ ì½”ë“œë¥¼ ë³´ë©´, `NaN`ì„ í™•ì¸í•˜ê¸° ìœ„í•´ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ `std::isnan` ë©”ì„œë“œê°€ ì‚¬ìš©ë©ë‹ˆë‹¤. ì´ëŠ” `NaN`ì´ ìë°”ìŠ¤í¬ë¦½íŠ¸ì™€ ë¬´ê´€í•˜ê²Œ ë“±ì¥í–ˆë‹¤ëŠ” ê²ƒì„ ì‹œì‚¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ê·¸ë¦¬ê³  ì‹¤ì œë¡œ ì—­ì‚¬ë¥¼ ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°€ ë³´ë©´, `NaN`ì˜ ìµœì´ˆ í‘œì¤€í™”ëŠ” 1985ë…„ì— ë“±ì¥í–ˆìœ¼ë©° [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)ë¼ëŠ” ë²ˆí˜¸ê°€ ë¶€ì—¬ë˜ì—ˆìŠµë‹ˆë‹¤.

## ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œ í•˜ë“œì›¨ì–´ ìˆ˜ì¤€ê¹Œì§€

ì´ ì§€ì‹ì„ ë°”íƒ•ìœ¼ë¡œ, ë¸Œë¼ìš°ì € ì½”ë“œì—ì„œ ì°¾ì€ ë‚´ìš©ì„ ê¸°ë°˜ìœ¼ë¡œ `NaN`ì´ ì–´ë–»ê²Œ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸í•˜ëŠ” ê°„ë‹¨í•œ C í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•´ ë³´ê² ìŠµë‹ˆë‹¤.

```js
> NaN !== NaN
true
> 0 / 0
NaN
```

```c
#include <math.h>
#include <stdint.h>
#include <stdio.h>

int main() {
    double x = 0.0 / 0.0;

    if (x != x) {
        printf("NaN is not the same\n");
    }
    if (isnan(x)) {
        printf("x is NaN\n");
    }

    uint64_t bits = *(uint64_t*)&x;

    printf("NaN hex: 0x%016lx\n", bits);

    return 0;
}
```

ê²°ê³¼ëŠ” ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œì™€ ë™ì¼í•©ë‹ˆë‹¤!

```bash
NaN is not the same
x is NaN
NaN hex: 0xfff8000000000000
```

ìš°ë¦¬ëŠ” `NaN`ì´ ë‹¤ë¥¸ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì—ì„œë„ ë°œê²¬ëœë‹¤ëŠ” ê²ƒì„ ì´ë¯¸ ì•Œê³  ìˆìŠµë‹ˆë‹¤.

```python
#Python

import math

nan = float('nan')
print(nan != nan)  # True
print(nan == nan)  # False
print(math.isnan(nan))  # True
```

```c++
//C++

#include <iostream>
#include <cmath>

int main() {
    double nan = NAN;
    std::cout << (nan != nan) << std::endl;  // 1 (true)
    std::cout << (nan == nan) << std::endl;  // 0 (false)
    std::cout << std::isnan(nan) << std::endl;  // 1 (true, proper way)
    return 0;
}
```

```rust
//Rust

fn main() {
    let nan = f64::NAN;
    println!("{}", nan != nan);  // true
    println!("{}", nan == nan);  // false
    println!("{}", nan.is_nan());  // true (proper way)
}
```

í•˜ì§€ë§Œ ì—¬ì „íˆ ê·¸ê²ƒì´ ë¬´ì—‡ì„ ìœ„í•œ ê²ƒì¸ì§€ëŠ” ëª¨ë¦…ë‹ˆë‹¤.

ì—¬ì „íˆ ì´ìœ ë¥¼ ì•Œ ìˆ˜ ì—†ìœ¼ë‹ˆ, ìš°ë¦¬ì˜ ê°„ë‹¨í•œ í”„ë¡œê·¸ë¨ìœ¼ë¡œ ì–´ì…ˆë¸”ë¦¬ ì½”ë“œë¥¼ ìƒì„±í•´ ë³´ê² ìŠµë‹ˆë‹¤ (í”„ë¡¤ë¡œê·¸ì™€ ìŠ¤íƒ í”„ë ˆì„ ì´ˆê¸°í™”ëŠ” ê±´ë„ˆë›°ê² ìŠµë‹ˆë‹¤).

```asm
# =====================================
#     double x = 0.0 / 0.0;
# =====================================
	pxor	xmm0, xmm0                 # xmm0 = 0.0
	divsd	xmm0, xmm0                 # xmm0 = 0.0 / 0.0 = NaN
	movsd	QWORD PTR -8[rbp], xmm0    # x = NaN

# =====================================
#     if (x != x) {
# =====================================
	movsd	xmm0, QWORD PTR -8[rbp]    # xmm0 = x
	ucomisd	xmm0, QWORD PTR -8[rbp]    # compare x with x (sets PF=1 for NaN)
	jnp	.L2                            # skip if NOT NaN (PF=0)
	# NaN detected - code here
.L2:

# =====================================
#     if (isnan(x)) {
# =====================================
	movsd	xmm0, QWORD PTR -8[rbp]    # xmm0 = x
	ucomisd	xmm0, QWORD PTR -8[rbp]    # compare x with x (sets PF=1 for NaN)
	jnp	.L3                            # skip if NOT NaN (PF=0)
	# NaN detected - code here
.L3:
```

ì–´ì…ˆë¸”ë¦¬ë¥¼ ì ‘í•´ë³´ì§€ ì•Šì€ ë¶„ë“¤ì„ ìœ„í•´ ì„¤ëª…í•˜ìë©´, `xmm0` ë ˆì§€ìŠ¤í„°ëŠ” ë¶€ë™ì†Œìˆ˜ì  ì—°ì‚°ì„ ìˆ˜í–‰í•˜ëŠ” ë ˆì§€ìŠ¤í„°ì…ë‹ˆë‹¤. ë…¼ë¦¬ì ìœ¼ë¡œ ìƒê°í•´ë³´ë©´, ìš°ë¦¬ëŠ” ìˆ«ì ì—°ì‚°ì„ ìˆ˜í–‰í•˜ê³  ì‹¶ê³ , CPUëŠ” ìˆ«ìë¥¼ ì²˜ë¦¬í•˜ë‹ˆê¹Œ, ì´ëŸ° ëª©ì ìœ¼ë¡œ íŠ¹ë³„íˆ ì„¤ê³„ëœ ë ˆì§€ìŠ¤í„°ì—ì„œ ì‘ì—…í•˜ëŠ” ê²Œ ê°€ì¥ ë¹ ë¥¼ ìˆ˜ë°–ì— ì—†ê² ì£ !

ë˜í•œ `NaN`ì„ ê°ì§€í–ˆì„ ë•Œ í”Œë˜ê·¸ë¥¼ ì„¤ì •í•˜ëŠ” `ucomisd` ëª…ë ¹ì–´ë„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì—¬ê¸°ì„œ ì–´ë–¤ ê²°ë¡ ì„ ë‚´ë¦´ ìˆ˜ ìˆì„ê¹Œìš”? `NaN`ì€ ìë°”ìŠ¤í¬ë¦½íŠ¸ ì¶”ìƒí™” ìˆ˜ì¤€ì´ ì•„ë‹Œ í•˜ë“œì›¨ì–´ ìˆ˜ì¤€ì—ì„œ êµ¬í˜„ëœë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤.
ê·¸ëŸ¬ë‹ˆ ë¶ˆí•„ìš”í•œ ì¶”ìƒí™”ë¥¼ í”¼í•˜ê¸° ìœ„í•´ ì–´ì…ˆë¸”ë¦¬ì–´ë¡œ í”„ë¡œê·¸ë¨ì„ ë‹¤ì‹œ ì‘ì„±í•˜ê³ , ê·¸ ì‹¤í–‰ ê²°ê³¼ë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

```c
#include <stdio.h>
#include <stdint.h>

int main() {
    double x;
    uint64_t bits;

    __asm__ (
        // double x = 0.0 / 0.0;
        "pxor   xmm0, xmm0\n\t"         // xmm0 = 0.0
        "divsd  xmm0, xmm0\n\t"         // xmm0 = 0.0 / 0.0 = NaN

        // Save results
        "movsd  %0, xmm0\n\t"           // x = NaN
        "movq   %1, xmm0\n\t"           // bits = *(uint64_t*)&x

        : "=m" (x), "=r" (bits)
        :
        : "xmm0"
    );

    int is_not_equal;
    __asm__ (
        // if (x != x)
        "movsd  xmm0, %1\n\t"           // xmm0 = x
        "ucomisd xmm0, %1\n\t"          // compare x with x â†’ PF=1 for NaN
        "setp   al\n\t"                 // al = (x != x)
        "movzx  %0, al\n\t"             // is_not_equal = al

        : "=r" (is_not_equal)
        : "m" (x)
        : "xmm0", "al"
    );

    if (is_not_equal) {                 // if (x != x)
        printf("NaN is not the same\n");
    }

    int is_nan_result;
    __asm__ (
        // if (isnan(x))
        "movsd  xmm0, %1\n\t"           // xmm0 = x
        "ucomisd xmm0, %1\n\t"          // compare x with x â†’ PF=1 for NaN
        "setp   al\n\t"                 // al = isnan(x)
        "movzx  %0, al\n\t"             // is_nan_result = al

        : "=r" (is_nan_result)
        : "m" (x)
        : "xmm0", "al"
    );

    if (is_nan_result) {                // if (isnan(x))
        printf("x is NaN\n");
    }

    printf("NaN hex: 0x%016lx\n", bits);

    return 0;
}
```

ê²°ê³¼ëŠ” ì–´ë–¨ê¹Œìš”?

```bash
NaN is not the same
x is NaN
NaN hex: 0xfff8000000000000
```

í”„ë¡œê·¸ë¨ì˜ ì¶œë ¥ì€ ê³ ìˆ˜ì¤€ ì–¸ì–´ì¸ Cì™€ ë™ì¼í•©ë‹ˆë‹¤.

ìš°ë¦¬ëŠ” `NaN`ì´ ë„¤ì´í‹°ë¸Œë¡œ êµ¬í˜„ë˜ì–´ ìˆìŒì„ ì´ë¯¸ ì•Œê³  ìˆìœ¼ë‹ˆ, `ucomisd` ëª…ë ¹ì–´ë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

```asm
"ucomisd xmm0, %1\n\t"          // compare x with x â†’ PF=1 for NaN
```

`ucomisd`ëŠ” **U**nordered **Compa**re **S**calar **D**ouble-precision floating-point(ìˆœì„œ ì—†ëŠ” ìŠ¤ì¹¼ë¼ ë°°ì •ë°€ë„ ë¶€ë™ ì†Œìˆ˜ì  ë¹„êµ)ì˜ ì•½ìì…ë‹ˆë‹¤. ì´ ë©‹ì§„ ëª…ë ¹ì–´ëŠ” x86 ì•„í‚¤í…ì²˜ í”„ë¡œê·¸ë˜ë¨¸ë“¤ì˜ ì‹œê°„ê³¼ ì‹ ê²½ì„ ì ˆì•½í•´ ì£¼ì—ˆìŠµë‹ˆë‹¤. ì™œëƒí•˜ë©´ CPU ìˆ˜ì¤€ì—ì„œ ì´ë¯¸ ìˆ«ì ì—°ì‚° ê²°ê³¼ê°€ ì˜¬ë°”ë¥¸ì§€ ì•„ë‹Œì§€ë¥¼ í™•ì¸í•´ ì£¼ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

## NaN !== NaN

ì£¼ëœ ì´ìœ ëŠ” í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì— `isnan()` í•¨ìˆ˜ê°€ ì•„ì§ ì¡´ì¬í•˜ì§€ ì•Šë˜ ì‹œì ˆ, í”„ë¡œê·¸ë˜ë¨¸ë“¤ì—ê²Œ `x != x` í…ŒìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•´ `NaN`ì„ ê°ì§€í•  ë°©ë²•ì„ ì œê³µí•˜ê¸° ìœ„í•¨ì´ì—ˆìŠµë‹ˆë‹¤.

ë…¼ë¦¬ì ì¸ ê´€ì ì—ì„œ ë³¼ ë•Œ, ì´ëŠ” ë§¤ìš° íƒ€ë‹¹í•©ë‹ˆë‹¤. ì™œëƒí•˜ë©´ 'ê°’ì´ ì•„ë‹˜'ì€ 'ê°’ì´ ì•„ë‹˜'ê³¼ ê°™ì„ ìˆ˜ ì—†ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

ì´ê²ƒì€ ë²„ê·¸ê°€ ì•„ë‹ˆë¼ **ì˜ë„ëœ ì„¤ê³„**ì…ë‹ˆë‹¤.

## typeof NaN === â€œnumberâ€

`NaN`ì€ ë³„ë„ì˜ íƒ€ì…ì´ ì•„ë‹ˆë¼ ìˆ«ì ì‹œìŠ¤í…œ(`IEEE 754`)ì˜ ì¼ë¶€ì…ë‹ˆë‹¤. ì´ëŠ” ìˆ˜í•™ì  ì—°ì‚° ì˜¤ë¥˜ë¥¼ ì•Œë¦¬ëŠ” íŠ¹ë³„í•œ ìˆ«ì ê°’ì…ë‹ˆë‹¤.

## IEEE 754-1985: ì´ì§„ ë¶€ë™ ì†Œìˆ˜ì  ì‚°ìˆ  í‘œì¤€

- ë°œí‘œ: 1985ë…„
- ì €ì: ìœŒë¦¬ì—„ ì¹´í•œ(UC ë²„í´ë¦¬) + IEEE ìœ„ì›íšŒ
- ì •ì˜: NaN, ë¬´í•œ(Infinity), ë¹„ì •ê·œí™”ëœ ìˆ˜(denormalized numbers), ë°˜ì˜¬ë¦¼ ëª¨ë“œ

### ì£¼ìš” ê²°ì • ì‚¬í•­

- `NaN !== NaN` (ë™ë“± ë¹„êµ ì‹œ í•­ìƒ `false`)
- ì§€ìˆ˜(Exponent) = `0x7FF`, ê°€ìˆ˜(mantissa) â‰  0
- **Quiet NaN** (qNaN) - ì˜ˆì™¸ë¥¼ ì•Œë¦¬ì§€ ì•Šê³  ì—°ì‚°ì„ í†µí•´ ì „íŒŒë¨
- **Signaling NaN** (sNaN) - ì—°ì‚°ì— ì²˜ìŒ ì‚¬ìš©ë  ë•Œ ì˜ˆì™¸ë¥¼ ìƒì„±í•¨
- `NaN` ì „íŒŒ (`NaN`ê³¼ì˜ ëª¨ë“  ì—°ì‚° â†’ `NaN`)

## NaNì€ ìˆ«ìì…ë‹ˆë‹¤, í•˜ì§€ë§Œ ì–´ë–¤ ì¢…ë¥˜ì¼ê¹Œìš”?

`0/0`ì„ ë‚˜ëˆ„ëŠ” ë° ì™œ ë¶€ë™ ì†Œìˆ˜ì  ìˆ«ì ë ˆì§€ìŠ¤í„°ê°€ ì‚¬ìš©ë˜ëŠ”ì§€ ê¶ê¸ˆí•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œ `number` íƒ€ì… ê°’ì— ëŒ€í•œ ì—°ì‚°ì€ IEEE 754 í‘œì¤€ì— ë”°ë¼ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ ë°°ì •ë°€ë„ ë¶€ë™ ì†Œìˆ˜ì  ìˆ«ì(double)ë¡œ í‘œí˜„ë©ë‹ˆë‹¤.

ì •ìˆ˜ ì—°ì‚°ì—ì„œ 0ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ê²ƒì€ ëª…ë°±í•œ ì˜¤ë¥˜ì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ë¶€ë™ ì†Œìˆ˜ì  ìˆ«ìì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ë˜ì§€ ì•Šì€ ê²°ê³¼ë¥¼ ì´ˆë˜í•  ìˆ˜ ìˆëŠ” ë§ì€ ê²½ìš°ê°€ ìˆìŠµë‹ˆë‹¤.

- `0.0 / 0.0` â†’ `NaN`
- `âˆ - âˆ` â†’ `NaN`
- `0 * âˆ` â†’ `NaN`
- `sqrt(-1)` â†’ `NaN`

IEEE 754 í‘œì¤€ì´ ì—†ì—ˆì„ ë•Œ, ê° í•˜ë“œì›¨ì–´ ì œì¡°ì‚¬ëŠ” ì´ëŸ¬í•œ ìƒí™©ì„ ì œê°ê¸° ë‹¤ë¥´ê²Œ ì²˜ë¦¬í–ˆìœ¼ë©°, ì´ëŠ” ì—„ì²­ë‚œ ì½”ë“œ ì´ì‹ì„± ë¬¸ì œë¥¼ ì•¼ê¸°í–ˆìŠµë‹ˆë‹¤.

## 1994ë…„: íœí‹°ì—„ FDIV ë²„ê·¸

íœí‹°ì—„ì˜ ë¶€ë™ ì†Œìˆ˜ì  ë‚˜ëˆ—ì…ˆ ë²„ê·¸ - ì¼ë¶€ ë‚˜ëˆ—ì…ˆì´ ë¶€ì •í™•í•œ ê²°ê³¼ë¥¼ ë°˜í™˜í–ˆìŠµë‹ˆë‹¤. `NaN`ê³¼ ê´€ë ¨ëœ ë¬¸ì œëŠ” ì•„ë‹ˆì—ˆì§€ë§Œ, ì´ëŠ” ì •í™•í•œ IEEE 754 êµ¬í˜„ì˜ ì¤‘ìš”ì„±ì„ ë³´ì—¬ì£¼ì—ˆìŠµë‹ˆë‹¤.

ì¸í…”ì€ ìˆ˜ë°±ë§Œ ê°œì˜ í”„ë¡œì„¸ì„œë¥¼ êµì²´í–ˆìœ¼ë©°, ì´ë¡œ ì¸í•´ 4ì–µ 7,500ë§Œ ë‹¬ëŸ¬ì˜ ë¹„ìš©ì´ ë°œìƒí–ˆìŠµë‹ˆë‹¤.

## í”„ë¡œê·¸ë˜ë¨¸ì˜ êµ¬ì›ì, NaN

`NaN`ì´ í•˜ë“œì›¨ì–´ ìˆ˜ì¤€ì—ì„œ ì„¤ì •ëœë‹¤ëŠ” ê²ƒì„ ë°°ì› ëŠ”ë°, `NaN` ì´ì „ì—ëŠ” ë¬´ì—‡ì´ ìˆì—ˆì„ê¹Œìš”?

IEEE 754 í‘œì¤€(1985ë…„) ì´ì „ì—ëŠ” ê° í•˜ë“œì›¨ì–´ ì œì¡°ì‚¬ê°€ ì œê°ê°ì˜ ë°©ì‹ì„ ì‚¬ìš©í–ˆìœ¼ë©°, ì´ëŠ” ë³´í†µ `0/0` ê°™ì€ ì—°ì‚°ì´ í”„ë¡œê·¸ë¨ ì¶©ëŒ ë° ì¢…ë£Œë¡œ ì´ì–´ì§„ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í–ˆìŠµë‹ˆë‹¤.

ì´ë¡œ ì¸í•´ ê°œë°œìë“¤ì€ ë§¤ìš° ë°©ì–´ì ì¸ í”„ë¡œê·¸ë˜ë°ì„ í•´ì•¼ í–ˆìŠµë‹ˆë‹¤. ë¹„í–‰ê¸°ë¥¼ ì¡°ì¢…í•˜ê³  ìˆëŠ”ë°, ì œì–´ ì‹œìŠ¤í…œì˜ í”„ë¡œê·¸ë˜ë¨¸ê°€ `0/0`ì„ ì˜ˆìƒí•˜ì§€ ëª»í–ˆë‹¤ê³  ìƒìƒí•´ ë³´ì„¸ìš”. í•´ë‹¹ ëª…ë ¹ì–´ê°€ CPUì—ì„œ ì‹¤í–‰ë˜ê³  'Division Error'ë¡œ ì¸í•´ í”„ë¡œê·¸ë¨ ì „ì²´ê°€ ë‹¤ìš´ë©ë‹ˆë‹¤!

ì¸í…”ê³¼ ë‹¤ë¥¸ ì œì¡°ì‚¬ë“¤ì€ ì•„í‚¤í…ì²˜ë§ˆë‹¤ í”„ë¡œê·¸ë¨ì´ ë‹¤ë¥´ê²Œ ë™ì‘í•˜ëŠ” í˜¼ë€ì— ì§ˆë ¤ë²„ë ¸ìŠµë‹ˆë‹¤.

## NaN (Not a Number)

ì™œ ë‹¤ë¥¸ í•´ê²°ì±… ëŒ€ì‹  íŠ¹ë³„í•œ ê°’ì„ ì‚¬ìš©í–ˆëŠ”ì§€ ìë¬¸í•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì—¬ëŸ¬ ì˜µì…˜ì„ ê³ ë ¤í•´ ë³´ê² ìŠµë‹ˆë‹¤.

### ì˜µì…˜ A: Division Error â†’ í”„ë¡œê·¸ë¨ ì¶©ëŒ (IEEE 754 ì´ì „ ë°©ì‹)

- ì˜ˆìƒì¹˜ ëª»í•œ í”„ë¡œê·¸ë¨ ì¢…ë£Œ (ë¹„í–‰ê¸° ì˜ˆì‹œ ì°¸ê³ )
- ëª¨ë“  ì—°ì‚° ì „ì— ë°©ì–´ì ì¸ í”„ë¡œê·¸ë˜ë° í•„ìš”

### ì˜µì…˜ B: ì˜ˆë¥¼ ë“¤ì–´ 0ì„ ë°˜í™˜

- ìˆ˜í•™ì ìœ¼ë¡œ ë¶€ì •í™•í•¨
- ì˜¤ë¥˜ë¥¼ ìˆ¨ê¹€
- ì´í›„ ê³„ì‚°ì´ ì˜ëª»ëœ ê²°ê³¼ë¥¼ ë„ì¶œí•¨

### ì˜µì…˜ C: `null` ë˜ëŠ” íŠ¹ë³„í•œ ì˜¤ë¥˜ ì½”ë“œ ë°˜í™˜

- ëª¨ë“  ì—°ì‚° í›„ í™•ì¸ í•„ìš”
- ìˆ˜í•™ì  ê³„ì‚°ì˜ ì—°ì†ì„±ì„ ë°©í•´í•¨
- ê²°ê³¼ íƒ€ì…ì´ ì¼ê´€ë˜ì§€ ì•Šê²Œ ë¨

### ì˜µì…˜ D: íŠ¹ë³„í•œ ê°’ `NaN` ë°˜í™˜ (IEEE 754ê°€ ì±„íƒ)

- ê°’ì´ ê³„ì‚°ì„ í†µí•´ ì „íŒŒë¨
- í”„ë¡œê·¸ë¨ì€ ê³„ì† ì‹¤í–‰ë¨
- ê³„ì‚° ë§ˆì§€ë§‰ì— ê²°ê³¼ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŒ
- íƒ€ì… ì¼ê´€ì„± ìœ ì§€ (ê³„ì† number íƒ€ì…)

## `NaN`ì´ ì—†ì—ˆë‹¤ë©´ ì–´ë• ì„ê¹Œìš”?

```js
function divide(a, b) {
  // íƒ€ì…ì„ í™•ì¸í•©ë‹ˆë‹¤.
  if (typeof a !== 'number' || typeof b !== 'number') {
    throw new Error('Arguments must be numbers');
  }

  // ìœ íš¨í•˜ì§€ ì•Šì€ ìˆ«ìì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
  if (!isFinite(a) || !isFinite(b)) {
    throw new Error('Arguments must be finite');
  }

  // ë‚˜ëˆ„ëŠ” ìˆ˜ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
  if (b === 0) {
    throw new Error('Division by zero');
  }

  return a / b;
}

function calculate(expression) {
  try {
    const result = divide(10, 0);
    return result;
  } catch (e) {
    console.error(e.message);
    return null; // ë¬´ì—‡ì„ ë¦¬í„´í•´ì•¼ í• ê¹Œìš”? null? undefined? 0?
  }
}
```

## `NaN` ë•ë¶„ì— ë¬´ì—‡ì„ ì–»ì—ˆì„ê¹Œìš”?

```js
function divide(a, b) {
  return a / b; // ë‚˜ë¨¸ì§€ëŠ” í•˜ë“œì›¨ì–´ì˜ ëª«ì…ë‹ˆë‹¤!
}

function calculate(expression) {
  return divide(10, 0);
}

const result = calculate('10 / 0');
console.log('Result:', result); // Infinity

const badResult = 0 / 0;
if (Number.isNaN(badResult)) {
  console.log('Invalid calculation');
}
```

## ìš”ì•½

`NaN`ì€ ë¶€ë™ ì†Œìˆ˜ì  ê³„ì‚°ì˜ ì˜¤ë¥˜ ì²˜ë¦¬ì— ëŒ€í•œ ìš°ì•„í•œ í•´ê²°ì±…ì…ë‹ˆë‹¤.

- í•˜ë“œì›¨ì–´ ìˆ˜ì¤€ì—ì„œ êµ¬í˜„ë¨ (`ucomisd` ëª…ë ¹ì–´)
- 1985ë…„ë¶€í„° IEEE 754 í‘œì¤€ì˜ ì¼ë¶€
- ì—°ì‚°ì„ í†µí•´ ì „íŒŒë˜ë©°, ê³„ì‚° ë§ˆì§€ë§‰ì— ì˜¤ë¥˜ ê°ì§€ë¥¼ í—ˆìš©í•¨
- `NaN !== NaN`ì€ `NaN` ê°ì§€ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ì˜ë„ëœ ì„¤ê³„ì„
- `typeof NaN === "number"`ëŠ” `NaN`ì´ ë³„ë„ íƒ€ì…ì´ ì•„ë‹Œ ìˆ«ì ì‹œìŠ¤í…œì˜ ì¼ë¶€ì´ê¸° ë•Œë¬¸ì„

## References

- [https://github.com/piotrzarycki/nan-from-scratch](https://github.com/piotrzarycki/nan-from-scratch)
- [https://en.wikipedia.org/wiki/Pentium_FDIV_bug](https://en.wikipedia.org/wiki/Pentium_FDIV_bug)
- [https://en.wikipedia.org/wiki/IEEE_754](https://en.wikipedia.org/wiki/IEEE_754)
- [https://csapp.cs.cmu.edu/public/waside/waside-sse.pdf](https://csapp.cs.cmu.edu/public/waside/waside-sse.pdf)

> ğŸš€ í•œêµ­ì–´ë¡œ ëœ í”„ëŸ°íŠ¸ì—”ë“œ ì•„í‹°í´ì„ ë¹ ë¥´ê²Œ ë°›ì•„ë³´ê³  ì‹¶ë‹¤ë©´ [Korean FE Article](https://kofearticle.substack.com/)ì„ êµ¬ë…í•´ì£¼ì„¸ìš”!
