---
title: 'Today I Learned'
date: 2022-07-05
lastUpdated: 2022-07-07
description: '작고 사소한 개발 지식'
tags: [Typescript]
---

## 220705

**import path 단축하기**

```ts
// package.json

"baseUrl": ".",
"paths": {
  "@libs/*": ["libs/*"]
}

// usage
import something from '@libs/server/handler';
```

**프로젝트 구성**

- 모노레포
  - 별도 환경설정에 소모하는 시간을 줄일 수 있음
  - 디자인 시스템과 같이 실시간으로 보면서 개발해야하는 특수한 경우 훨씬 간편하게 watch를 걸고 빌드할 수 있음.
  - 팀 간의 작업 현황에 관심을 가질 수 있음. 커밋 기록 등등으로. 눈에 보이니 PR참여도 쉬워짐.
  - 팀마다의 커밋 기록이 섞여 지저분해짐 (히스토리 파악 어려워짐)
  - 팀마다의 테스트서버 QA / 배포 프로세스가 꼬일 수 있음. 단독으로 관리하기 어려움.
  - 공통 모듈에 수정이 가해질 경우 모든 팀의 프로젝트가 다 배포되어야 함.
- 단독 레포
  - 팀마다의 단독 개발 환경 (테스트, 배포)을 구축할 수 있음
  - 공통 모듈에 수정이 가해진다 해도 필요한 팀에서만 버전을 올려 사용하고 배포하면 됨.
  - 히스토리를 깔끔하게 관리할 수 있음
  - 디자인 시스템, 이메일 템플릿과 같은 공통 모듈이지만 단독으로 관리되는 경우 실시간 수정하기 매우 귀찮음.
  - 초기 구축 비용이 소모됨
  - 다른 팀의 현황에 관심을 갖기 힘들 수 있음 (눈에서 멀어지므로)

## 220707

**써드파티 라이브러리에 대해 인터페이스를 만들자는 의견**

- 인터페이스 자체가 변화가 적고 표준이 확실한 경우, 매우 유용할 것 같다.
  - 예시: http client, api interface 등
- 하지만 그렇지 않은 경우 인터페이스를 만드는 것이 오히려 독이 될 수 있을 것 같다.
  - 변화가 잦고 인터페이스의 공통화가 쉽지 않은 라이브러리
  - 해결하고 싶은 문제는 같지만 해결방법이 각기 다른 라이브러리
  - 승리한 해결방법이 명확히 없는 영역
  - 예시 : 상태관리, 폼 관리 등등

```js
// get.js
import first from 'first';

const get = first.get;

export { get };

// usage
get(successFn, objectData);

// 몇 달 뒤...
// get.js
import something from 'something';

// 의도: 라이브러리 교체를 위해 인터페이스에서만 변경 발생하게 하는 것.
const get = something.get;

export { get };

// usage
// 근데 교체한 라이브러리의 함수가 받는 인자가 완전히 달라진다면?
get(FailFn, arrayData);
```

이렇게 인터페이스를 만들어둔다 해도 인자 같은 것이 완전히 변하면, 결국 get 사용처를 수정해야 하는 것 아닌가? 즉, 인터페이스가 무의미해지는 것 아닌가?  
이럴땐 어떻게 하는걸까?

**Kent C의 테스트 코드 스터디 : 테스트 코드에 있어 리버스 엔지니어링**

- 통합 테스트를 한다는 건 내부의 로직을 모르는 상황에서 테스트를 하는 것인데, 이 과정을 리버스 엔지니어링이라고 본걸까?
- 내부 로직이 어떻게 동작하는지 알고 있기 때문에 작성할 수 있는 테스트 방식이 아닐까?
- 특별한 장점은 없는 것 같다.
- 감추고 싶은 부분(private)을 테스트하는 것이라 오히려 별로인듯.

## 220711

프로젝트 설계 & 구성을 시작했다.  
모노레포 vs 멀티레포 중 당장의 빠른 개발을 위해 모노레포를 선택했는데 git 전략이 문제였다.

**Git 브랜치 전략**

conflict는 문제가 되지 않는다. 왜냐하면 turborepo로 filter 할 거라서.  
그런데, turborepo는 git이 아니다.  
모노레포를 위한 도구가 git과 배포에 밀접하게 연관되는 게 과연 괜찮은가?

1. main, dev, feature, release, hotfix 로 구성된 전략
   - 가장 익숙한 모델이다
   - main에 반영되는 커밋은 곧바로 운영에 배포되고, dev에 반영되는 커밋은 곧바로 개발 서버에 배포된다.
   - dev를 main에 넣을 땐 release를 따서 버저닝 하여 넣는다.
   - hotfix가 필요할 땐 main에서 따서 pr merge 후 로컬에선 dev에 리베이스하여 반영한다.
   - 한 레포에 한 프로젝트 (팀)일 때 적용하기 쉬운 전략이다
   - 한 레포에 여러 프로젝트 (팀)이라면, 5개의 브랜치를 관리하는 것이 어려울 수 있다.
2. main, feature로만 구성된 전략
   - 사실 내게는 낯선 모델이다
   - 빠른 배포를 목적으로 한다
   - main에서 feature를 따서 개발, qa 후 곧바로 main에 넣어 운영배포한다.
   - feature가 나와있는 기간이 길수록 conflict가 발생할 확률이 높아지므로 빠르게 머지하는 것이 중요하다.
   - qa를 하려면 개발 서버가 필요한데 (dev 또는 test) 해당 브랜치가 main과 완전히 동기화 되지 않음이 걱정된다.
   - 관리해야하는 브랜치의 수가 적어 모노레포 환경에서 덜 혼란스러울 수 있다.

현재 우리 팀의 상황을 살펴보면

- 운영 오픈된 프로젝트 1개, 이제 막 새롭게 개발 시작하는 프로젝트 3개.
- 3개는 초기 단계라 모든 것이 빠르게 변하고 진행되기 때문에 버저닝이 필요하지 않다. (기획단의 요구도 없음)
- 총 3팀, 6명이 한 레포 안에서 (모노레포) 작업을 진행한다.
- 이전 서비스 개발시 여러 작업자가 존재할 경우 dev에서의 qa와 main으로의 배포 과정에서 고초를 겪었던 경험이 있다.

결론: 빠르게 시도하고 실패하고 개선하자.

**Git merge 전략**

현재의 github에서는 세 가지의 merge를 제공하고 있다.  
우리 팀에서는 어떤 전략을 채택할지에 대해 논의했는데, 전제는 "1. merge 전 rebase 수행 2. 커밋 메세지를 상세히 작성할 것"이다.

1. merge commit
   - 일반적으로 아는 그 머지이다.
   - 머지 커밋이 생성된다. 이 점이 지저분해지기에 맘에 안듦.
   - 모든 커밋을 보존한다.
2. squash merge
   - 여러 커밋이 하나의 대왕 커밋으로 퉁쳐지기 때문에 히스토리가 보존되지 않는다는 단점이 있다.
   - commit revert 할 때 하나의 커밋만 하면 된다는 장점이 있다.
   - 커밋 내역이 commit body로 남고, 상세 커밋별 파일 체인지를 보고 싶다면 해당 피알 링크를 눌러 이동해 보면 되긴 하지만 모든 pr마다 다 이동해서 봐야한다는 귀찮은 단점이 있다.
   - github의 스쿼시 머지는 머지 커밋이 남지 않아 깔끔하다.
   - dev(또는 main) 기준에서 jira의 한 티켓 당 하나의 커밋만이 쌓이는 것이기 때문에 그래프가 깔끔할 수 있다.
3. rebase merge
   - 커밋을 squash 하지 않으면서도 머지 커밋이 생성되지 않는다.
   - 머지 커밋 없이 티켓 번호 prefix만 보고 구분해야 한다.
