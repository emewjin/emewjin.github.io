{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/relay-style-graphql/","result":{"data":{"site":{"siteMetadata":{"title":"emewjin.log","siteUrl":"https://emewjin.github.io"}},"markdownRemark":{"id":"fc9eae14-9844-5be6-84bf-5f482ef36b37","tableOfContents":"<ul>\n<li>\n<p><a href=\"#shifting-goals\">Shifting Goals</a></p>\n</li>\n<li>\n<p><a href=\"#some-optional-history\">Some (Optional) History</a></p>\n</li>\n<li>\n<p><a href=\"#highlights-of-relay-style-graphql\">Highlights of Relay-style GraphQL</a></p>\n<ul>\n<li>\n<p><a href=\"#fragment-collocation\">Fragment Collocation</a></p>\n<ul>\n<li>\n<p><a href=\"#an-example-relay-component\">An example Relay component</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B4%EC%A0%90-1-over-fetching-%EB%B0%A9%EC%A7%80\">이점 #1: over-fetching 방지</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B4%EC%A0%90-2-under-fetching-%EB%B0%A9%EC%A7%80\">이점 #2: under-fetching 방지</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B4%EC%A0%90-3-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%8D%94-%EC%89%BD%EA%B2%8C-%EC%B6%94%EB%A1%A0%ED%95%A0-%EC%88%98-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4\">이점 #3: 컴포넌트를 더 쉽게 추론할 수 있습니다.</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B4%EC%A0%90-4-%ED%96%A5%EC%83%81%EB%90%9C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9C%A0%ED%98%95\">이점 #4: 향상된 타입스크립트 유형</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B4%EC%A0%90-5-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A7%8C-%EC%86%90%EC%89%BD%EA%B2%8C-%EB%8B%A4%EC%8B%9C-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0\">이점 #5: 컴포넌트의 데이터만 손쉽게 다시 가져오기</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B4%EC%A0%90-6-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EA%B0%80-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%97%90-%EB%94%B0%EB%9D%BC-%EB%8B%A4%EB%A5%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EA%B0%80%EC%A0%B8%EC%98%AC-%EC%88%98-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4\">이점 #6: 컴포넌트가 컨텍스트에 따라 다른 데이터를 가져올 수 있습니다.</a></p>\n<ul>\n<li><a href=\"#%EC%8B%A4%EC%A0%9C-%EB%AC%B8%EC%A0%9C%EC%A0%90-%EC%82%AC%EB%A1%80\">실제 문제점 사례</a></li>\n<li><a href=\"#the-solution\">The Solution</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B4%EC%A0%90-7-better-graphql-apis\">이점 #7: Better GraphQL APIs</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B4%EC%A0%90-8-%EC%9A%94%EC%95%BD\">이점 #8: 요약</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#data-fetching\">Data Fetching</a></p>\n<ul>\n<li><a href=\"#easy-pretty-good-performance\">Easy, pretty-good performance</a></li>\n<li><a href=\"#medium-effort-better-performance\">Medium-effort, better performance</a></li>\n<li><a href=\"#high-effort-best-possible-performance\">High-effort, best-possible performance</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#persisted-queries\">Persisted Queries</a></p>\n</li>\n<li>\n<p><a href=\"#react-suspense-support\">React Suspense Support</a></p>\n</li>\n<li>\n<p><a href=\"#developer-experience\">Developer Experience</a></p>\n<ul>\n<li><a href=\"#required-fields\">@required fields</a></li>\n<li><a href=\"#language-server-protocol--vs-code-extension\">Language Server Protocol / VS Code Extension</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#and-more\">And more!</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#whats-not-great\">What’s Not Great</a></p>\n</li>\n<li>\n<p><a href=\"#faq\">FAQ</a></p>\n<ul>\n<li><a href=\"#q-why-do-i-need-relay-style-graphql-if-\">Q: Why do I need Relay-style GraphQL if …</a></li>\n<li><a href=\"#q-will-relay-fall-apart-\">Q: Will Relay fall apart …</a></li>\n<li><a href=\"#q-how-do-you-unit-test-\">Q: How do you unit test …</a></li>\n<li><a href=\"#q-do-collocated-fragments-ever-result-in-conflicts-\">Q: Do collocated fragments ever result in conflicts …</a></li>\n<li><a href=\"#q-will-relay-take-away-control-i-have-over-\">Q: Will Relay take away control I have over …</a></li>\n</ul>\n</li>\n</ul>","excerpt":"원문: https://alan.norbauer.com/articles/relay-style-graphql 이 글은 원작자의 동의를 받고 한국어로 번역되었습니다. 오역 또는 더 정확한 표현에 대한 코멘트는 항상 환영입니다! ”미래형 Relay-style GraphQL…","html":"<blockquote>\n<p>원문: <a href=\"https://alan.norbauer.com/articles/relay-style-graphql\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://alan.norbauer.com/articles/relay-style-graphql</a><br>\n이 글은 원작자의 동의를 받고 한국어로 번역되었습니다.<br>\n오역 또는 더 정확한 표현에 대한 코멘트는 항상 환영입니다!</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>”<del>미래형</del> Relay-style GraphQL은 이미 존재한다 - 다만 고르게 퍼져있지 않을 뿐이다.”<br>\n– William Gibson, probably</p>\n</blockquote>\n<p>“Relay-style GraphQL”은 React 어플리케이션에서 GraphQL을 사용하는 한 가지 방법이며, <em>아마도</em> 현재 사용하고 있는 방법보다 더 나은 방법일 것입니다. 이 방법은 Meta의 GraphQL 오픈소스 라이브러리, <a href=\"https://relay.dev/\" title=\"https://relay.dev/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Relay</a>의 아이디어를 따릅니다.</p>\n<p>Relay는 이러한 아이디어<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>를 독점하지 않으며, Apollo와 같은 프레임워크로도 충분히 Relay 스타일의 GraphQL을 작성할 수 있습니다. 반대로, Relay로도 충분히 구식 GraphQL을 작성할 수도 있습니다. 이 용어는 <em>기술적으로 가능한 것과는 관계없이</em>, 최신 버전의 Relay 스타일로 작성된 GraphQL 코드와 그렇지 않은 오늘날 대부분의 다른 GraphQL 코드의 스타일 차이를 설명하는 것으로 생각하면 됩니다.</p>\n<h2 id=\"shifting-goals\" style=\"position:relative;\"><a href=\"#shifting-goals\" aria-label=\"shifting goals permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Shifting Goals</h2>\n<p>다음은 2015년에 우리가 가졌던 높은 수준의 목표와 오늘날 Relay-style의 GraphQL이 해결하고자 하는 목표를 비교한 것입니다:</p>\n<table>\n<thead>\n<tr>\n<th><strong>GraphQL in 2015</strong></th>\n<th><strong>Relay-style GraphQL</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>- 데이터 쿼리를 위한 선언적인 언어<br>- REST보다 유연하지만, BE이 더 많이 노출됨<br>- 일부 over-fetching 방지<br>- 퍼포먼스(성능)는 ????????????<br>- schemas 및 type 안정성 (REST가 제거한)을 되찾음<br>더 나은 개발자 경험(DX)</td>\n<td>- UI components가 그들의 데이터 종속성을 선언할 수 있음<br>- REST보다 더 안전하고 빠르며 locked-down<br>- 절대 과소 또는 과잉 fetch 하지 않음<br>- 가능한한 최고의 퍼포먼스<br>- 컴포넌트에 맞게 더욱 향상된 type 안정성<br>- 놀라운 개발자 경험</td>\n</tr>\n</tbody>\n</table>\n<p>이러한 목표를 달성할 수 있는 방법에 대해 설명해 드리겠습니다. 하지만 그 전에 먼저…</p>\n<h2 id=\"some-optional-history\" style=\"position:relative;\"><a href=\"#some-optional-history\" aria-label=\"some optional history permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Some (Optional) History</h2>\n<p>Meta는 2012년에 GraphQL을 시작하여 2015년에 오픈소스로 공개했습니다. GraphQL 이전에는 REST가 있었고, 그 이전에는 SOAP가 있었습니다. GraphQL은 REST 백엔드보다 더 나은 무언가로 모바일 애플리케이션을 구축하고자 하는 열망에서 시작되었습니다.<br>\n2015년 이후 웹 UI 커뮤니티 내에서는 놀랍게도 교차 수분<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>이 거의 없는 두 개의 평행한 evolution 트랙이 존재했습니다:</p>\n<ul>\n<li>\n<p><a href=\"https://www.apollographql.com/\" title=\"https://www.apollographql.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Apollo</a>가 주도하는 오픈소스 커뮤니티</p>\n</li>\n<li>\n<p>메타 / 메타의 (역시 오픈소스인) <a href=\"https://relay.dev/\" title=\"https://relay.dev/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Relay</a></p>\n</li>\n</ul>\n<p>오픈소스 커뮤니티는 <a href=\"https://the-guild.dev/\" title=\"https://the-guild.dev/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">The Guild</a>의 놀라운 작업과 같이 GraphQL을 개선했지만, 2016년 첫 출시 이후 Apollo를 사용하는 방식은 근본적으로 동일하게 유지되고 있습니다. 주요 발전은 더디게 진행되고 있으며(예: <code class=\"language-text\">useFragment</code> 는 아직 실험 중임), 일부 훌륭한 발전(예: <a href=\"https://www.apollographql.com/docs/devtools/editor-plugins/\" title=\"https://www.apollographql.com/docs/devtools/editor-plugins/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the VS Code Plugin</a>)의 채택은 저에게는 불안정적으로 보입니다. </p>\n<p>메타가 모바일에서 GraphQL을 채택한 것은 즉각적인 성공을 거두었지만, 웹에서 수용하는 데는 오픈소스에 비해 훨씬 못 미쳤으며, 페이스북에 도입하는 데 10년이 걸렸습니다. 여러 번의 시도가 실패로 돌아갔고, 실패할 때마다 기술 스택(예: Relay)을 다시 생각하게 되었으며, 결국에는 처음 시작했을 때와 오늘날 대부분의 업계와는 매우 다른 접근 방식으로 성공할 수 있었습니다.</p>\n<p>Meta의 노력의 결실과 오픈 소스에서 얻은 교훈이 바로 “Relay-style GraphQL”이라고 부르는 것입니다. 모든 사람이 Relay-style GraphQL의 모든 부분을 필요로 하는 것은 아니며, 특히 최상의 성능과 이전 버전과의 호환성, 그리고 그에 수반되는 모든 인프라와 도구의 복잡성을 필요로 하는 것은 아니지만, 다른 대부분의 발전은 모든 애플리케이션과 매우 관련이 있습니다.</p>\n<h2 id=\"highlights-of-relay-style-graphql\" style=\"position:relative;\"><a href=\"#highlights-of-relay-style-graphql\" aria-label=\"highlights of relay style graphql permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Highlights of Relay-style GraphQL</h2>\n<p>Relay-style GraphQL은 많은 프레임워크 기능, 모범 사례 및 다른 사고방식을 결합한 접근 방식입니다. 그중 몇 가지를 강조하고 싶습니다:</p>\n<h3 id=\"fragment-collocation\" style=\"position:relative;\"><a href=\"#fragment-collocation\" aria-label=\"fragment collocation permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fragment Collocation</h3>\n<p>Fragment collocation은 GraphQL fragment를 다른 별도의 파일이 아닌 컴포넌트 안에 직접 선언하는 것을 의미합니다. 부모 컴포넌트는 자식 컴포넌트의 fragment들을 그들의 fragment에 spread해서 자식 컴포넌트를 렌더링합니다.</p>\n<p>Apollo는 더 낮은 형태의 <a href=\"https://www.apollographql.com/blog/graphql/fragments/using-graphql-fragments-for-safer-cleaner-and-faster-code/\" title=\"https://www.apollographql.com/blog/graphql/fragments/using-graphql-fragments-for-safer-cleaner-and-faster-code/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">collocated fragments</a> 를 지원하며 <a href=\"https://www.apollographql.com/docs/react/api/react/hooks-experimental/#usefragment\" title=\"https://www.apollographql.com/docs/react/api/react/hooks-experimental/#usefragment\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">더 나은 collocated fragments</a> 는 아직 베타입니다.</p>\n<p>collocation of fragments를 잘 사용하는 두 가지 <strong>중요한</strong> 원칙은 다음과 같습니다.:</p>\n<ul>\n<li>\n<p>컴포넌트는 절대 GraphQL 출처의 data를 props를 통해 받아선 안됩니다: 컴포넌트의 fragment(s)에서 선언한 데이터에만 접근 가능해야 합니다.</p>\n</li>\n<li>\n<p>컴포넌트는 절대 fragments를 공유해선 안됩니다. Relay는 fragment의 이름이 컴포넌트 이름으로 시작하도록 강제합니다.</p>\n</li>\n</ul>\n<h4 id=\"an-example-relay-component\" style=\"position:relative;\"><a href=\"#an-example-relay-component\" aria-label=\"an example relay component permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>An example Relay component</h4>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">//issueSummary.tsx</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">IssueSummary</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  issue<span class=\"token operator\">:</span> IssueSummaryFragment$key<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> issue <span class=\"token operator\">=</span> <span class=\"token function\">useFragment</span><span class=\"token punctuation\">(</span>\n    graphql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n      fragment IssueSummaryFragment on Issue {\n        title\n        body\n      }\n    </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n    props<span class=\"token punctuation\">.</span>issue\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>issue<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>issue<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>부모 컴포넌트는 자신의 fragment에서 이 fragment를 spread하고 자식 컴포넌트를 렌더링합니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// issues.tsx</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Issues</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  repository<span class=\"token operator\">:</span> IssuesFragment$key <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token function\">useFragment</span><span class=\"token punctuation\">(</span>\n    graphql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n      fragment IssuesFragment on Repository {\n        issues(first: 1) {\n          nodes {\n            __id\n            ...IssueSummaryFragment\n        }\n      }\n    </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n    props<span class=\"token punctuation\">.</span>repository\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span> <span class=\"token attr-name\">className</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>styles<span class=\"token punctuation\">.</span>issues<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token punctuation\">{</span>data<span class=\"token operator\">?.</span>issues<span class=\"token punctuation\">.</span>nodes<span class=\"token operator\">?.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>issue<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>issue <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">IssueSummary</span></span> <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>issue<span class=\"token punctuation\">.</span>__id<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">issue</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>issue<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>최상위 컴포넌트는 쿼리를 생성하고 (직접적으로 또는 경유적으로) 모든 하위 컴포넌트의 모든 fragment을 spread합니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// mainView.tsx</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">MainView</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  queryRef<span class=\"token operator\">:</span> PreloadedQuery<span class=\"token operator\">&lt;</span>MainViewQuery<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token function\">usePreloadedQuery</span><span class=\"token punctuation\">(</span>\n    graphql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n      query MainViewQuery($owner: String!, $name: String!) {\n        repository(owner: $owner, name: $name) {\n          owner {\n            login\n          }\n          name\n          ...IssuesFragment\n        }\n      }\n    </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n    props<span class=\"token punctuation\">.</span>queryRef\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>결과는 다음과 같이 이 최상위 쿼리를 <code class=\"language-text\">MainViewQuery.graphql</code>  파일에 수동으로 작성했을 때와 동일합니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token comment\"># MainViewQuery.graphql</span>\n<span class=\"token keyword\">query</span> <span class=\"token definition-query function\">MainViewQuery</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$owner</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">String</span><span class=\"token operator\">!</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$name</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">String</span><span class=\"token operator\">!</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property-query\">repository</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">owner</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$owner</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">name</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token object\">owner</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">login</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token property\">name</span>\n    <span class=\"token property-query\">issues</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">first</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token object\">edges</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">__id</span>\n        <span class=\"token object\">node</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token property\">title</span>\n          <span class=\"token property\">number</span>\n          <span class=\"token object\">author</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token property\">login</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그러나 이 쿼리를 직접 작성하는 대신 Relay-style GraphQL 라이브러리를 사용하면 collocated fragment를 동일한 쿼리로 컴파일할 수 있으므로 많은 이점을 얻을 수 있습니다:</p>\n<h4 id=\"이점-1-over-fetching-방지\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A0%90-1-over-fetching-%EB%B0%A9%EC%A7%80\" aria-label=\"이점 1 over fetching 방지 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이점 #1: over-fetching 방지</h4>\n<p>Relay-style의 GraphQL 코드는 필요하지 않은 데이터를 가져오는 일이 없기 때문에 데이터 효율성이 완벽합니다.</p>\n<p>REST API는 이론적으로는 UI에 필요한 데이터를 정확히 가져오거나 요청된 데이터를 필터링하는 유연한 query parameters를 사용할 수 있지만<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>, 실제로는 UI에서 여러 use-case를 위해 오버페칭을 수행해야 합니다. Data Pruning<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>은 해결할 수 있지만 종종 무시되는 문제이기 때문에 REST API에서 제공하는 데이터는 일반적으로 UI에서 실제로 필요한 데이터보다 항상 상위 집합(superset)에 속합니다.</p>\n<p>GraphQL은 UI 작성자가 항상 필요한 데이터를 정확히 요청할 수 있도록하여 이론적으로 항상 완벽한 data-fetching 효율성을 달성하고 over-fetching을 방지함으로써 이 문제를 개선했습니다. </p>\n<p>문제는 여러 컴포넌트에서 GraphQL queries/fragments를 공유할 때 발생합니다: 정적 분석으로는 <code class=\"language-text\">.graphql</code>파일 안의 어떤 필드가 사용되지 않았는지, 그러므로 제거해도 안전한지를 알 수 없습니다<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup>.</p>\n<p>Relay-style Fragment collocation 은 이러한 문제를 해결합니다: 컴포넌트의 Fragment에서 필드를 제거하거나 컴포넌트만 제거하고 다른 컴포넌트에서 해당 필드를 참조하지 않는 경우, 별도로 해줄 일 없이 쿼리에서 해당 필드가 제거됩니다.</p>\n<p>Relay는 이 모든 작업을 용이하게 하는 도구를 구현합니다:</p>\n<ul>\n<li>\n<p><strong>Data Masking</strong>: 컴포넌트는 fragment에 선언한 내용만 볼 수 있습니다. 컴포넌트는 props를 통해 key를 받지만 이 key는 <code class=\"language-text\">useFragment</code> 와 같은 것을 통해 전달되기 전까지는 사용할 수 없으며 <code class=\"language-text\">useFragment</code> 가 반환하는 데이터는 컴포넌트의 fragment에서 정의된 데이터만 포함됩니다.</p>\n</li>\n<li>\n<p><strong>Lint rules:</strong> bad data fetching/passing practices를 초래할 수 있는 모든 행위를 방지합니다. 예: 자식 컴포넌트에게 전달하기만 하는 필드를 fragment를 추가한다거나, 직접 사용하지 않는 fragment를 spread하는 행위 등등.</p>\n</li>\n<li>\n<p><strong>TypeScript typing:</strong> fragment를 spread하지 않고 컴포넌트를 렌더링하는 것을 방지합니다.</p>\n</li>\n<li>\n<p>Etc.</p>\n</li>\n</ul>\n<h4 id=\"이점-2-under-fetching-방지\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A0%90-2-under-fetching-%EB%B0%A9%EC%A7%80\" aria-label=\"이점 2 under fetching 방지 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이점 #2: under-fetching 방지</h4>\n<p>Relay-style의 GraphQL 코드에는 쿼리되지 않은 데이터를 컴포넌트가 필요로 하는 버그가 없습니다.</p>\n<p>fragment collocation이 없으면 의존하는 데이터를 <em>항상</em> 가져오지 않는 React 컴포넌트를 작성할 수 있습니다. 예를 들어, <code class=\"language-text\">firstName</code> , <code class=\"language-text\">lastName</code>  필드가 있는 <code class=\"language-text\">User</code> 객체가 필요한 컴포넌트가 있다고 가정해 봅시다. 컴포넌트는 이 필드가 nullable임을 알고 있고 적절한 <code class=\"language-text\">null</code> 검사를 수행하지만, 컴포넌트를 사용하는 모든 쿼리에 두 필드가 모두 포함된다고 보장할 수는 없습니다. 이로 인해 런타임에 컴포넌트가 예기치 않게 <code class=\"language-text\">null</code>을 반환하는 버그가 발생할 수 있습니다. UI는 이 오류 사례를 거의 기록하지 않습니다.<br>\nfragment collocation을 사용하면 querying 없이 컴포넌트를 렌더링할 수 없기 때문에 컴포넌트에 필요한 모든 데이터가 항상 쿼리된다는 것을 보장할 수 있습니다. 필드가 여전히 <code class=\"language-text\">null</code>이 될 수 있긴 하지만 그건 GraphQL 코드의 버그 때문이 아닙니다.</p>\n<h4 id=\"이점-3-컴포넌트를-더-쉽게-추론할-수-있습니다\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A0%90-3-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%8D%94-%EC%89%BD%EA%B2%8C-%EC%B6%94%EB%A1%A0%ED%95%A0-%EC%88%98-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\"이점 3 컴포넌트를 더 쉽게 추론할 수 있습니다 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이점 #3: 컴포넌트를 더 쉽게 추론할 수 있습니다.</h4>\n<p>collocated fragments이 위에서 말했던 첫 번째 원칙(아래 인용구)을 준수하는 경우:</p>\n<blockquote>\n<p>“컴포넌트는 절대 GraphQL 출처의 data를 props를 통해 받아선 안됩니다: 컴포넌트의 fragment(s)에서 선언한 데이터에만 접근 가능해야 합니다.”</p>\n</blockquote>\n<p>추론하기가 훨씬 쉬워집니다. 이것은 제가 개인적으로 가장 좋아하는 collocated fragments의 이점이며, Relay 스타일 GraphQL의 이점이기도 합니다.</p>\n<p>예를 들어, prop에서 GraphQL 데이터를 가져오는 React 컴포넌트를 생각해 봅시다:</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// issueTitle-legacy.tsx</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">IssueTitle</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> issue<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> title<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token operator\">|</span><span class=\"token keyword\">null</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>issue<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 컴포넌트는 매우 간단해 보이지만 컴포넌트를 렌더링하기 위해 title의 출처에 대한 정보가 필요한 경우 다른 곳에서 검색해야 합니다. 혹은 렌더링시 또 다른 필드를 사용하고 싶으신가요? prop에 추가한 다음 데이터의 출처를 찾아서 그곳에 필드를 추가해야 합니다.</p>\n<p>collocated fragment를 사용하는 GraphQL component와 비교해 보세요:</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// issueTitle.tsx</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">IssueTitle</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> issue<span class=\"token operator\">:</span> IssueTitleFragment$key <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> issue <span class=\"token operator\">=</span> <span class=\"token function\">useFragment</span><span class=\"token punctuation\">(</span>\n    graphql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n      fragment IssueTitleFragment on Issue {\n        title\n      }\n    </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n    props<span class=\"token punctuation\">.</span>issue\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>issue<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 코드에서  <code class=\"language-text\">title</code> 은 <code class=\"language-text\">Issue</code> type의 필드임을 쉽게 알 수 있습니다.</p>\n<p>이것에 대한 schema documentation를 보고싶으신가요? 마우스를 필드 위에 올리기만 하면 됩니다:</p>\n<p><img src=\"https://github.com/emewjin/emewjin.github.io/assets/76927618/7903d18a-b420-4956-a07a-14645cdcb3ae\" alt=\"alt_text\"></p>\n<p>schema로 이동하고 연관된 필드들을 보고 싶으신가요? 필드를 Cmd-click 하세요.</p>\n<p>다른 필드를 렌더링할 때 쓰고싶으신가요? 이 컴포넌트의 fragment에 추가하기만 하세요.</p>\n<h4 id=\"이점-4-향상된-타입스크립트-유형\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A0%90-4-%ED%96%A5%EC%83%81%EB%90%9C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9C%A0%ED%98%95\" aria-label=\"이점 4 향상된 타입스크립트 유형 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이점 #4: 향상된 타입스크립트 유형</h4>\n<p>collocated fragments이 위에서 말한 두 번째 원칙을 준수하는 경우:</p>\n<blockquote>\n<p>“컴포넌트는 절대로 fragments를 공유해서는 안 됩니다.”</p>\n</blockquote>\n<p>훨씬 나은 타입스크립트 typing 이점을 누릴 수 있습니다.</p>\n<p>GraphQL 데이터의 TypeScript typing이 좋지 않은 코드베이스에서 작업할 가능성이 있죠. 이런 일이 발생할 수 있는 케이스는 여러 가지가 있습니다. 예를 들어:</p>\n<ul>\n<li>\n<p>컴포넌트 prop의 definition에서 타입이 확장되는 경우. 예를 들어, GraphQL type은 string literal들의 union일 수 있지만 컴포넌트 prop은 이를 <code class=\"language-text\">string</code> 으로 확장합니다.</p>\n</li>\n<li>\n<p>GraphQL 데이터는 모든 GraphQL 타입을 유지하지 않는 변환 작업을 거치게 되며, 유지되는 type은 쿼리에 따라 특정 유형에서 degrade됩니다. 예를 들어, 한 필드에 대해 쿼리했지만 사용하게 되는 type은 abstract GraphQL type (쿼리하지 않았음에도 불구하고 모든 필드를 포함하고 모두 nullable한)입니다. 이 경우 사용하는 IDE의 자동 완성 기능은 잠재적으로 모든 필드에 액세스할 수 있다고 생각하므로 문제가 발생할 수 있습니다.</p>\n</li>\n<li>\n<p>Field types은 엄격하지 않은 타이핑과 바닐라 자바스크립트를 통해 손실됩니다.</p>\n</li>\n</ul>\n<p>엄격하지 않고 엄격한 타입스크립트가 없는 코드베이스일지라도 Relay-style 컴포넌트에서의 GraphQL의 타입은 항상 완벽합니다. 왜냐하면 컴포넌트는 fragment를 기반으로 하는 자체 자동 생성된 custom type을 가져오기 때문입니다. 나머지 코드베이스는 중요하지 않습니다. 그리고 props로 GraphQL 데이터를 전달하지 않기 때문에 유형이 절대 degrade되지 않습니다.</p>\n<p>fragment에 필드가 없으면 다른 컴포넌트가 해당 필드를 쿼리하는지 여부에 관계없이 TypeScript type에 해당 필드가 없습니다. TypeScript type은 컴포넌트를 완벽하게 나타냅니다.</p>\n<p>각 fragment에 대해 custom TypeScript type을 사용하면 나중에 설명할 <a href=\"#required-fields\">다른 개발자 경험의 이점</a>도 얻을 수 있습니다.</p>\n<h4 id=\"이점-5-컴포넌트의-데이터만-손쉽게-다시-가져오기\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A0%90-5-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A7%8C-%EC%86%90%EC%89%BD%EA%B2%8C-%EB%8B%A4%EC%8B%9C-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0\" aria-label=\"이점 5 컴포넌트의 데이터만 손쉽게 다시 가져오기 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이점 #5: 컴포넌트의 데이터만 손쉽게 다시 가져오기</h4>\n<p>GraphQL을 fragment로 분리하면 전체 쿼리 대신 컴포넌트에 필요한 데이터만 쉽게 다시 refetch할 수 있도록 설정할 수도 있습니다. 예를 들어 Relay를 사용하면, 호출 시 fragment에 있는 데이터만 쿼리를 전송하는 함수를 자동으로 생성하는 re-fetchable fragment로 <a href=\"https://relay.dev/docs/guided-tour/refetching/refreshing-fragments/#using-userefetchablefragment\" title=\"https://relay.dev/docs/guided-tour/refetching/refreshing-fragments/#using-userefetchablefragment\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">간단하게 업그레이드</a>할 수 있습니다.</p>\n<p>collocated fragments이 없으면 두 가지 선택지가 있습니다.</p>\n<ul>\n<li>\n<p>전체 쿼리를 다시 요청하거나</p>\n</li>\n<li>\n<p>원하는 데이터만 다시 가져오는 함수를 수동으로 작성하고 새로 가져온 데이터를 반영하도록 로컬 캐시를 수동으로 변경합니다.</p>\n</li>\n</ul>\n<p>보너스: graph의 item에 전역적으로 고유한 ID를 사용하면 하나의 컴포넌트에 대해서만 데이터를 다시 가져와도 UI에서 데이터 불일치가 발생하지 않습니다. 자동 생성된 re-fetch 함수에 두 개의 다른 컴포넌트에서 렌더링되는 항목에 대한 데이터가 있는 경우, UI는 두 곳 모두에서 새로운 데이터를 사용합니다(Relay의 정규화된 저장소<sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup>를 사용합니다).</p>\n<h4 id=\"이점-6-컴포넌트가-컨텍스트에-따라-다른-데이터를-가져올-수-있습니다\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A0%90-6-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EA%B0%80-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%97%90-%EB%94%B0%EB%9D%BC-%EB%8B%A4%EB%A5%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EA%B0%80%EC%A0%B8%EC%98%AC-%EC%88%98-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\"이점 6 컴포넌트가 컨텍스트에 따라 다른 데이터를 가져올 수 있습니다 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이점 #6: 컴포넌트가 컨텍스트에 따라 다른 데이터를 가져올 수 있습니다.</h4>\n<h5 id=\"실제-문제점-사례\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%EC%A0%9C-%EB%AC%B8%EC%A0%9C%EC%A0%90-%EC%82%AC%EB%A1%80\" aria-label=\"실제 문제점 사례 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실제 문제점 사례</h5>\n<p>데이터를 두 단계로 렌더링하는 컴포넌트가 있습니다. 데이터를 미리 볼 때 한 번, 저장한 후에 한 번 더 렌더링합니다. 미리 보기 단계에서, 동일한 type을 가지고 있음에도 불구하고 백엔드에서 모든 필드를 사용할 수 있는 것은 아닙니다. <code class=\"language-text\">id</code> 필드가 그러합니다. 이 때문에 스키마에서 다르게 모델링 되었어야 하지만, 이 문제는 잠시 접어두겠습니다. 미리 보기 단계에서 사용할 수 없는 필드에 <code class=\"language-text\">@skip</code> 조건을 추가하여 이 문제를 해결했지만, <code class=\"language-text\">@skip</code> 변수를 넣을 수 있는 유일한 위치는 default parameter가 있는 query variable뿐입니다. 결국 다음과 같이 작성되었습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token comment\"># garbage.graphql</span>\n<span class=\"token keyword\">query</span> <span class=\"token definition-query function\">PreviewItemQuery</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$isForPreview</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">Boolean</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span><span class=\"token fragment function\">ItemFragment</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">query</span> <span class=\"token definition-query function\">SavedItemQuery</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$isForPreview</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">Boolean</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span><span class=\"token fragment function\">ItemFragment</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fragment</span> <span class=\"token fragment function\">ItemFragment</span> <span class=\"token keyword\">on</span> <span class=\"token class-name\">Item</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">id</span> <span class=\"token directive function\">@skip</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">if</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$isForPreview</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>query variables는 전역 변수로 어떻게 사용될 것인지와 뚜렷한 연관성이 없기 때문에 이렇게 작성하는 것은 좋지 않습니다. 또한 실제 query variable도 아닙니다: 이것은 앞으로도 쭉 쿼리에 전달되지 않을 것이며 오직 기본 상태로만 사용하고 있습니다.</p>\n<p>또한 이것은 오류를 발생시킬 여지가 되기도 합니다. 왜냐하면 이 query variable를 사용하는 fragment를 일시적으로 포함하지 않는 쿼리에 이 query variable를 추가하는 것은 <em><strong>런타임 에러</strong></em>이기 때문입니다<sup id=\"fnref-7\"><a href=\"#fn-7\" class=\"footnote-ref\">7</a></sup>. 컴파일 시간 동안에는 아무 반응도 없었습니다. GraphQL 프레임워크가 컴파일할 수 있도록 허용하는 것과 GraphQL 서버가 유효한 쿼리로 간주하는 것 사이의 임피던스 불일치(Impedance mismatch)로 인해 <strong>프로덕션 환경에서 오류가 발생했습니다.</strong></p>\n<br>\n<h5 id=\"the-solution\" style=\"position:relative;\"><a href=\"#the-solution\" aria-label=\"the solution permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Solution</h5>\n<p>어떻게 해야 할까요? 우선, 위의 문제를 컴파일러 오류로 처리할 수 있는 충분한 정적 분석을 수행하는 GraphQL 프레임워크를 사용하세요. 더 좋은 방법은 fragment arguments를 사용하는 것입니다! fragment arguments는 기본적으로 GraphQL fragment에 대한 함수 인자입니다. 다음은 Relay에서의 <a href=\"https://relay.dev/docs/api-reference/graphql-and-directives/#argumentdefinitions\" title=\"https://relay.dev/docs/api-reference/graphql-and-directives/#argumentdefinitions\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">fragment argument definition</a>입니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// previewItem.tsx</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">PreviewItem</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  item<span class=\"token operator\">:</span> PreviewItemFragment$key<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> item <span class=\"token operator\">=</span> <span class=\"token function\">useFragment</span><span class=\"token punctuation\">(</span>\n    graphql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n      fragment PreviewItemFragment on Item @argumentDefinitions(\n        isForPreview: { type: \"Boolean!\" }\n      ) {\n        id @skip(if: $isForPreview)\n        title\n      }\n    </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n    props<span class=\"token punctuation\">.</span>item\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그러면 컴파일 타임에 이 인수가 모든 spread된 fragment에 전달되도록 강제합니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// preview.tsx</span>\n<span class=\"token operator\">...</span>PreviewItemFragment @<span class=\"token function\">arguments</span><span class=\"token punctuation\">(</span>isForPreview<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>또한 fragment를 정의, 사용, 호출할 때 인자가 collocated fragment 와 동일한 위치에 있으므로 해당 인자가 왜 존재하는지, 어떻게 사용되는지 추측할 필요가 없습니다.</p>\n<h4 id=\"이점-7-better-graphql-apis\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A0%90-7-better-graphql-apis\" aria-label=\"이점 7 better graphql apis permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이점 #7: Better GraphQL APIs</h4>\n<p>Collocated fragments를 사용하면 UI component에 맞게 구성된 간단한 GraphQL API를 구축할 수 있습니다. 이를 통해 데이터 복잡성을 데이터의 원래 위치인 백엔드로 옮길 수 있습니다.</p>\n<h4 id=\"이점-8-요약\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A0%90-8-%EC%9A%94%EC%95%BD\" aria-label=\"이점 8 요약 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이점 #8: 요약</h4>\n<p><strong>단 한 가지만 흡수한다면, 이 점만 기억하세요:</strong> 손으로 작성한 GraphQL 쿼리 (fragment로 나누든 아니든)를 React 컴포넌트와 collocated된 GraphQL fragment로 전환하는 것은 즉시 사용자를 만족시킬 수 있고 다시는 이전 방식으로 돌아갈 수 없게 만들 많은 downstream 이점<sup id=\"fnref-8\"><a href=\"#fn-8\" class=\"footnote-ref\">8</a></sup>을 가지고 있습니다.</p>\n<h3 id=\"data-fetching\" style=\"position:relative;\"><a href=\"#data-fetching\" aria-label=\"data fetching permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Data Fetching</h3>\n<p>Relay-style GraphQL 을 사용하면 매우 우수한 data-fetching 성능을 쉽게 확보할 수 있으며 동시에 높은 노력을 들인 가능한한 최상의 성능을 구현할 수 있습니다.</p>\n<h4 id=\"easy-pretty-good-performance\" style=\"position:relative;\"><a href=\"#easy-pretty-good-performance\" aria-label=\"easy pretty good performance permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Easy, pretty-good performance</h4>\n<p>이것이 기본 설정입니다. 추가 노력 없이 초기 설정만으로 모든 GraphQL fragment들은 쿼리로 컴파일되고 배치 처리됩니다. 페이지 로드시 리액트 컴포넌트가 렌더링을 시작한 후 1개의 GraphQL 쿼리를 수행하도록 하게 하기 위해 page 또는 route당 1개의 <strong>GraphQL 네트워크 요청을 가져야 합니다.</strong></p>\n<p>이는 이미 평균적인 Apollo 앱보다 나은 수준이며 아마도 이것으로 충분할 것입니다:</p>\n<ul>\n<li>\n<p>Enterprise/internal 애플리케이션</p>\n</li>\n<li>\n<p>성능이 최고가 아니더라도 이탈하고 싶지 않아하는 고정 유저가 있는 애플리케이션</p>\n</li>\n<li>\n<p>페이지 로딩 시간을 약간이라도 단축시키는 것이 개발자가 쓰는 비용보다 가치가 없는 애플리케이션</p>\n</li>\n<li>\n<p>더 나은 기기와 인터넷 속도를 쓰는 유저가 있는 애플리케이션</p>\n</li>\n<li>\n<p>대부분의 유저가 desktop 유저인 애플리케이션</p>\n</li>\n<li>\n<p>Etc.</p>\n</li>\n</ul>\n<h4 id=\"medium-effort-better-performance\" style=\"position:relative;\"><a href=\"#medium-effort-better-performance\" aria-label=\"medium effort better performance permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Medium-effort, better performance</h4>\n<p>성능 향상을 위한 다음 단계는 data fetching을 React rendering과 디커플링 시키는 것입니다. React팀은 fetch-on-render 대신 <a href=\"https://legacy.reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html#render-as-you-fetch\" title=\"https://legacy.reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html#render-as-you-fetch\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">render-as-you-fetch</a> 를 지지하며, 이는 Relay-style GraphQL이 지원합니다 (<a href=\"https://alan.norbauer.com/articles/relay-style-graphql#persisted-queries\" title=\"https://alan.norbauer.com/articles/relay-style-graphql#persisted-queries\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">compiled, persisted queries</a> 그리고 <a href=\"https://relay.dev/docs/api-reference/use-preloaded-query\" title=\"https://relay.dev/docs/api-reference/use-preloaded-query\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">query preloading</a> 와 같은 기능을 통해서요).</p>\n<p>유저가 URL 바에서 엔터 키를 누르면, 서버는 초기 HTML 문서를 전송하는 동시에 데이터를 fetching하고 스트리밍하기 시작해야 합니다. 유저가 lazy-load되는 콘텐츠가 있는 모달을 열기 위해 버튼을 클릭하면, 서버는 버튼이 클릭된 즉시 모달의 데이터를 가져와야 합니다 (JS 코드로 모달을 구동시키는 것과 병렬로). <strong>이 모델에서 page/route 당 클라이언트에서의 GraphQL 네트워크 요청은 0개이며, 사용자 상호작용으로 인해 더 많은 데이터가 필요한 경우마다 1개의 네트워크 요청이 발생합니다.</strong></p>\n<p>이 방식은 대부분의 애플리케이션에서 충분하며 특히 다음의 경우 유용합니다.</p>\n<ul>\n<li>\n<p>high-latency 모바일 연결을 사용하는 유저가 있는 애플리케이션</p>\n</li>\n<li>\n<p>성능 향상을 위해 더 많은 개발자 노력을 투자할 가치가 있는 애플리케이션</p>\n</li>\n<li>\n<p>Etc.</p>\n</li>\n</ul>\n<h4 id=\"high-effort-best-possible-performance\" style=\"position:relative;\"><a href=\"#high-effort-best-possible-performance\" aria-label=\"high effort best possible performance permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>High-effort, best-possible performance</h4>\n<p>점점 더 큰 GraphQL chunk를 단일 쿼리로 batch한 후, 불균형적으로 느린 field resolver들이 전체 데이터 패칭을 지연시키는 문제를 만날 수도 있습니다. Relay는 <code class=\"language-text\">@defer</code> 와 <code class=\"language-text\">@stream</code> directive를 제공하여 개별 필드를 제어할 수 있게 함으로써 이 문제를 해결합니다.</p>\n<p>또, GraphQL에 의해 발생한 문제는 아니지만 GraphQL로 해결할 수 있는 틈새 문제도 있습니다. 예를들어, 사람들이 다양한 글을 작성할 수 있는 포럼이 있고, 그 다양한 글들은 단 하나의 리액트 컴포넌트로만 렌더링 된다고 해봅시다. 시간이 지남에 따라 1,000 종류의 글이 누적되어 번들 크기가 엄청나게 커졌다고 가정해봅시다. 글들의 98%는 다섯 개의 컴포넌트로 렌더링 할 수 있지만, 컴포넌트의 long tail<sup id=\"fnref-9\"><a href=\"#fn-9\" class=\"footnote-ref\">9</a></sup>은 모두 소량만 사용됨을 관찰 할 수 있었습니다. 어떻게 해야 할까요? 한 가지 해결책은 클라이언트 렌더링을 중단하고 non-interactive하게 만드는 것입니다. 다른 방법도 있습니다: Relay의 <a href=\"https://relay.dev/docs/glossary/#3d\" title=\"https://relay.dev/docs/glossary/#3d\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Data-Driven Dependencies (3D)</a>을 사용하면 서버에서 반환하려는 GraphQL 데이터를 기반으로 클라이언트로 전송할 JS를 결정할 수 있습니다. 따라서 가장 많이 사용되는 5개의 컴포넌트를 기본 번들에 포함시켜 항상 준비하고, 추가로 전송하려는 GraphQL 응답에서 게시물을 렌더링하는 데 필요한 React 컴포넌트만 전송할 수 있습니다.</p>\n<p>이런 문제는 일반적이진 않지만 Relay-style GraphQL 프레임워크는 <em>필요하다면</em> 이런 수준의 제어도 가능합니다.</p>\n<p>이것은 대부분의 모든 애플리케이션에서 충분합니다:</p>\n<ul>\n<li>\n<p>수십억 명의 유저를 보유한 애플리케이션으로, 밀리초를 절약하는 것이 엄청난 개발 가치가 있는 애플리케이션</p>\n</li>\n<li>\n<p>개발자가 시간을 효율적으로 사용하기보다 언제나 가장 빠른 옵션을 구현하려고 하는 애플리케이션</p>\n</li>\n</ul>\n<h3 id=\"persisted-queries\" style=\"position:relative;\"><a href=\"#persisted-queries\" aria-label=\"persisted queries permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Persisted Queries</h3>\n<p>GraphQL API는 UI 개발자가 클라이언트에서 필요한 것을 직접 쿼리할 수 있는 기능을 제공하지만 여기에는 두 가지 문제가 있습니다:</p>\n<ol>\n<li>\n<p>클라이언트에 대량의 query document를 보내면 클라이언트가 이걸 다시 서버로 보내야 할 가능성이 있습니다. 이것은 bandwidth 낭비입니다.</p>\n</li>\n<li>\n<p>모든 클라이언트로부터 임의의 복잡한 쿼리를 수락하면 서비스 품질과 효율성에 악영향을 미칠 수 있으며 잠재적으로 보안 위험<sup id=\"fnref-10\"><a href=\"#fn-10\" class=\"footnote-ref\">10</a></sup>이 발생할 수 있습니다. 개발자들이 이 문제를 해결하는 한 가지 방법은 쿼리 복잡도를 계산한 다음 API 속도를 제한하는 것입니다. 이러한 접근 방식은 특정 상황에서만 의미가 있습니다.</p>\n</li>\n</ol>\n<p>이 두 가지 문제에 대한 한 가지 해결 방법은 <a href=\"https://relay.dev/docs/guides/persisted-queries/#the-persistconfig-option\" title=\"https://relay.dev/docs/guides/persisted-queries/#the-persistconfig-option\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">persisted queries</a>를 사용하는 것입니다.</p>\n<p>persisted query란 컴파일된 쿼리를 백엔드가 액세스 할 수 있는 곳에 지속시키고(persisting) 고유 ID를 할당하여 해당 고유 ID만 클라이언트에 전송하는 것을 의미합니다. 그러면 JS 애플리케이션은 쿼리를 실행할 때 해당 고유 ID와 함께 쿼리 변수를 GraphQL 서버로 전송하기만 하면 됩니다. 이렇게 하면 bandwidth 낭비를 없애고 쿼리를 UI 개발자가 작성한 쿼리로 제한하여 임의의 누군가가 JS 콘솔에서 쿼리를 보내지 못하게 할 수 있습니다.</p>\n<h3 id=\"react-suspense-support\" style=\"position:relative;\"><a href=\"#react-suspense-support\" aria-label=\"react suspense support permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React Suspense Support</h3>\n<p>Relay는 React Suspense를 완벽하게 지원합니다. 대부분의 GraphQL 라이브러리들은 최소한 experimental mode에서 이를 지원하며, React 팀은 Suspense가 <a href=\"https://react.dev/reference/react/Suspense\" title=\"https://react.dev/reference/react/Suspense\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">“opinionated data fetching frameworks.”</a>에 대해 안정적이라고 선언했습니다. 컴포넌트 가독성과 오류가 발생하기 쉬운 로딩 로직 제거에 대한 이점은 지금 바로 Suspense를 사용할 충분한 이유입니다.</p>\n<h3 id=\"developer-experience\" style=\"position:relative;\"><a href=\"#developer-experience\" aria-label=\"developer experience permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Developer Experience</h3>\n<p>Relay-style GraphQL에는 수많은 DX 이점이 있지만 저는 그중에서도 두 가지를 강조하고 싶습니다:</p>\n<h4 id=\"required-fields\" style=\"position:relative;\"><a href=\"#required-fields\" aria-label=\"required fields permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@required fields</h4>\n<p>GraphQL을 사용하면 스키마 수준에서 non-nullable 필드를 정의할 수 있지만, 복원력과 이전 버전과의 호환성 문제를 일으키지 않도록 그렇게 하지 말아야 한다는 것은 <a href=\"https://graphql.org/learn/best-practices/#nullability\" title=\"https://graphql.org/learn/best-practices/#nullability\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">잘 알려져 있습니다.</a> 스키마에서 non-nullable 필드를 사용하기 위해서는 엄청나게 높은 기준이 있습니다.</p>\n<p>하지만 <em>컴포넌트</em> 내부의 기준은 그다지 높지 않습니다. 컴포넌트를 작성할 때 “이 필드가 없으면 아무것도 렌더링하지 않는 것이 낫다”고 말하는 것이 합리적입니다. Relay에는 이와 같은 코드를 대체할 수 있는 <code class=\"language-text\">@required</code> directive가 있습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// issueSummary.tsx</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">IssueSummary</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  issue<span class=\"token operator\">:</span> IssueSummaryFragment$key<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> issue <span class=\"token operator\">=</span> <span class=\"token function\">useFragment</span><span class=\"token punctuation\">(</span>\n    graphql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n      fragment IssueSummaryFragment on Issue {\n        title\n        body\n        closed\n        createdAt\n      }\n    </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n    props<span class=\"token punctuation\">.</span>issue\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n    issue<span class=\"token punctuation\">.</span>title <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span>\n    issue<span class=\"token punctuation\">.</span>body <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span>\n    issue<span class=\"token punctuation\">.</span>closed <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span>\n    issue<span class=\"token punctuation\">.</span>createdAt <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>issue<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>issue<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>issue<span class=\"token punctuation\">.</span>closed<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>issue<span class=\"token punctuation\">.</span>createdAt<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드는 아래처럼 수정할 수 있습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// issueSummary.tsx</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">IssueSummary</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  issue<span class=\"token operator\">:</span> IssueSummaryFragment$key<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> issue <span class=\"token operator\">=</span> <span class=\"token function\">useFragment</span><span class=\"token punctuation\">(</span>\n    graphql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n      fragment IssueSummaryFragment on Issue {\n        title @required(action: LOG)\n        body @required(action: LOG)\n        closed @required(action: LOG)\n        createdAt @required(action: LOG)\n      }\n    </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n    props<span class=\"token punctuation\">.</span>issue\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>issue <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>issue<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>issue<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>issue<span class=\"token punctuation\">.</span>closed<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>issue<span class=\"token punctuation\">.</span>createdAt<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 변화가 그닥 많은 타이핑을 아끼지 않았을 수도 있지만… :</p>\n<ul>\n<li>\n<p>더 이상 두 개의 필드 목록을 동기화 하지 않아도 됩니다.</p>\n</li>\n<li>\n<p>원하는 TypeScript type이 바로 구성됩니다: 전체 issue가 null이거나 모든 필드가 non-nullable인 경우</p>\n</li>\n<li>\n<p>Relay version은 필드가 예상치 못하게 <code class=\"language-text\">null</code>인 경우 왼쪽의 코드가 자동으로 무시하는 대신 원격 분석 엔드포인트에 로그를 기록합니다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">@required</code> 는 필드가 <code class=\"language-text\">null</code>인 경우 예외를 던지는 것과 같은 다른 동작을 지원합니다. 이러한 예외는 구조화된 데이터와 함께 단일 병목 지점(single choke point)에서 발생하며, 재발 방지를 위한 모니터링 설정에 도움이 됩니다. 이는 ad-hoc(임시적) 에러 로깅 방식으로 얻을 수 없는, 더 효율적인 오류 처리 방식을 제공합니다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">@required</code>를 사용하여 <code class=\"language-text\">null</code> 필드를 컴포넌트 계층 구조를 통해 상위로 전파할 수 있으며 이는 단순히 <code class=\"language-text\">null</code> 을 반환하는 것과는 다른 방식으로 동작합니다.</p>\n</li>\n<li>\n<p>Etc.</p>\n</li>\n</ul>\n<h4 id=\"language-server-protocol--vs-code-extension\" style=\"position:relative;\"><a href=\"#language-server-protocol--vs-code-extension\" aria-label=\"language server protocol  vs code extension permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Language Server Protocol / VS Code Extension</h4>\n<p>GraphQL을 컴포넌트로 이동하면 언어-서버 프로토콜의 이점을 컴포넌트에 더 가깝게 가져올 수 있습니다. 컴포넌트에서 스키마 문서를 바로 가져오는 방법은 위를 참조하세요.</p>\n<h3 id=\"and-more\" style=\"position:relative;\"><a href=\"#and-more\" aria-label=\"and more permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>And more!</h3>\n<p>아직 다 말하지 못한 수많은 것들이 있습니다. 예를 들면 <a href=\"https://relay.dev/docs/guided-tour/updating-data/graphql-mutations/#declarative-mutation-directives\" title=\"https://relay.dev/docs/guided-tour/updating-data/graphql-mutations/#declarative-mutation-directives\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">declarative mutation directives</a>, <a href=\"https://relay.dev/docs/guided-tour/updating-data/graphql-mutations/#optimistic-response\" title=\"https://relay.dev/docs/guided-tour/updating-data/graphql-mutations/#optimistic-response\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">type-safe 낙관적 응답</a>, <a href=\"https://relay.dev/docs/guides/graphql-server-specification/\" title=\"https://relay.dev/docs/guides/graphql-server-specification/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GraphQL 서버와 UI 사이 더 밀접한 통합</a>의 이점, <a href=\"https://relay.dev/docs/guides/relay-resolvers/\" title=\"https://relay.dev/docs/guides/relay-resolvers/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Relay Resolvers</a>, Relay의 정규화된 스토어(store)는 응답 캐시보다 더 나은 memory footprint와 더 나은 garbage collection을 제공하며, 내장된 <a href=\"https://relay.dev/docs/guided-tour/list-data/pagination/\" title=\"https://relay.dev/docs/guided-tour/list-data/pagination/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">pagination implementation</a>, 데이터 업데이트 시 더 빠르고 효율적인 React 렌더링 등입니다. 목록은 계속 늘어날 것입니다.</p>\n<h2 id=\"whats-not-great\" style=\"position:relative;\"><a href=\"#whats-not-great\" aria-label=\"whats not great permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What’s Not Great</h2>\n<p>이쯤에서 Relay-style GraphQL이 React 애플리케이션에서 GraphQL API를 사용하는 데 있어 근본적으로 더 나은 접근 방식이라는 점을 이해하셨기를 바랍니다. 이 스타일(또는 Relay 자체)의 단점이 있는지 궁금하다면, 몇 가지를 알려드리겠습니다:</p>\n<ol>\n<li>\n<p>npm에서 Apollo는 Relay보다 <a href=\"https://npmtrends.com/@apollo/client-vs-react-relay\" title=\"https://npmtrends.com/@apollo/client-vs-react-relay\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">19배 더 많이 다운로드 됩니다.</a>:</p>\n<p><img src=\"https://github.com/emewjin/emewjin.github.io/assets/76927618/d99ad946-bba1-4eda-9159-5b4915022140\" alt=\"\"></p>\n<p>만약 엔지니어링 조직이 주니어에 치우쳐 있고 Relay보다 Apollo에 대한 글이 얼마나 더 많은지가 중요하다면 Apollo를 고수해야 할 수도 있습니다. 아니면 위험을 싫어하고 다른 사람들이 많이 사용하는 제품을 더 좋아할 수도 있습니다. 또는 인터넷 블로그 게시물에서 추천하는 제품 대신 다른 사람들이 사용하는 제품을 사용하는 것에 위안을 삼을 수도 있습니다. 그것도 아니면 그냥 큰 막대기를 좋아하실 수도 있습니다.</p>\n</li>\n<li>\n<p>Relay-style GraphQL은 컴파일러 단계가 필요합니다. 예를들어 Relay는 컴파일러<sup id=\"fnref-11\"><a href=\"#fn-11\" class=\"footnote-ref\">11</a></sup>가 있는데 개발할 때 watch mode에서 실행되고 있도록 해야 합니다.</p>\n</li>\n<li>\n<p>Relay의 문서는 꽤 훌륭하지만 완벽하지는 않습니다. 특히 메타만 사용하는 고급 기능으로 갈수록 문서화가 심하게 부족한 영역이 있습니다.</p>\n</li>\n<li>\n<p>Relay는 GraphQL 서버와 통합될 때 가장 잘 동작합니다. 이를 <a href=\"https://relay.dev/docs/guides/graphql-server-specification/\" title=\"https://relay.dev/docs/guides/graphql-server-specification/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GraphQL Server Specification</a> 이라고 하며 이 명세는 전역적으로 고유한 ID 사용, <code class=\"language-text\">@connection</code> directive 지원, 그리고 <code class=\"language-text\">Node</code> 인터페이스 제공 등을 설명합니다. 이는 좋은 기능이며 사용자의 편의를 높여주지만, 일부 조직에서는 UI 엔지니어가 GraphQL 서버 구현을 거의 제어할 수 없기 때문에 Relay의 잠재력을 최대한 발휘할 수 없을지도 모릅니다.</p>\n</li>\n</ol>\n<h2 id=\"faq\" style=\"position:relative;\"><a href=\"#faq\" aria-label=\"faq permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>FAQ</h2>\n<h3 id=\"q-why-do-i-need-relay-style-graphql-if-\" style=\"position:relative;\"><a href=\"#q-why-do-i-need-relay-style-graphql-if-\" aria-label=\"q why do i need relay style graphql if  permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Q: Why do I need Relay-style GraphQL if …</h3>\n<p>… 이미 Apollo와 함께 collocated fragments 를 사용하고 있고, 컴포넌트 간에 fragments를 공유하지 않으며, graphql-code-generator를 사용하여 모든 fragment에 대해 type을 생성하고, 생성된 fragment type을 사용하여 모든 input props를 입력하고 있는데도 Relay-style GraphQL이 필요할까요?</p>\n<p><strong>A:</strong> (1) 제가 현실 세계에서 본 적이 없는 방식으로 Apollo를 사용하고 계십니다. 아주 훌륭하게 들리며, 기본적으로 Relay-style GraphQL의 몇 가지 훌륭한 사례들을 직접 개발한 것에 대해 스스로 자랑스러워해야 합니다. (2) Apollo는 이 중 어떤 것도 쉽게 적용할 수 없습니다. 이 패턴을 고수하도록 설정할 수 있는 config나 린트 규칙이 없습니다. Relay를 사용하면 이 스타일에 대한 모든 것이 정적으로 적용됩니다.</p>\n<h3 id=\"q-will-relay-fall-apart-\" style=\"position:relative;\"><a href=\"#q-will-relay-fall-apart-\" aria-label=\"q will relay fall apart  permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Q: Will Relay fall apart …</h3>\n<p>… Relay가 복잡한 실제 어플리케이션에서 문제를 발생시키진 않을까요? 예제들은 단순해보입니다.</p>\n<p><strong>A:</strong> 아뇨.</p>\n<h3 id=\"q-how-do-you-unit-test-\" style=\"position:relative;\"><a href=\"#q-how-do-you-unit-test-\" aria-label=\"q how do you unit test  permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Q: How do you unit test …</h3>\n<p>… Relay components에 대한 단위 테스트는 어떻게 작성하나요?</p>\n<p><strong>A:</strong> 저는 end-to-end 테스트에 매우 매우 의존하는 코드베이스(그리고 UI 컴포넌트가 아닌 것에만 단위 테스트)에 대해서만 작업했습니다. 하지만 관심이 있으시다면 <a href=\"https://relay.dev/docs/guides/testing-relay-components/\" title=\"https://relay.dev/docs/guides/testing-relay-components/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">여기에 많은 내용이 있습니다.</a> 이걸 읽으면 어떻게 해야할지 알 수 있을 거예요!</p>\n<h3 id=\"q-do-collocated-fragments-ever-result-in-conflicts-\" style=\"position:relative;\"><a href=\"#q-do-collocated-fragments-ever-result-in-conflicts-\" aria-label=\"q do collocated fragments ever result in conflicts  permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Q: Do collocated fragments ever result in conflicts …</h3>\n<p>… 동일한 root field를 쿼리하지만 다른 argument를 사용하는 경우와 같이, 동일한 데이터를 한 컴포넌트와 다른 컴포넌트에서 어떻게 쿼리하는지에 대해서 충돌이 발생할까요? 모든 컴포넌트에서 필드를 수동으로 aliasing 해야할까요?</p>\n<p><strong>A:</strong> 아뇨, Relay가 대신 해줍니다. 서로 다른 두 fragment에서 동일한 필드에 서로 다른 argument를 전달하면 수동으로 aliasing할 필요 없이 각각 올바른 데이터(각 argument를 반영한)를 가져옵니다.</p>\n<h3 id=\"q-will-relay-take-away-control-i-have-over-\" style=\"position:relative;\"><a href=\"#q-will-relay-take-away-control-i-have-over-\" aria-label=\"q will relay take away control i have over  permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Q: Will Relay take away control I have over …</h3>\n<p>… 쿼리 캐시 사용 여부와 방법에 대한 통제권을 빼앗길까요?</p>\n<p><strong>A:</strong> 아니요, Relay의 <code class=\"language-text\">fetchPolicy</code>를 사용하면 네트워크 동작을 상당히 잘 제어할 수 있습니다. 그렇긴 하지만 fragment 단위로 제어할 수는 없으므로(그게 무슨 의미가 있겠습니까<sup id=\"fnref-12\"><a href=\"#fn-12\" class=\"footnote-ref\">12</a></sup>), 필요한 경우 컴포넌트를 lazy 로드되는 컴포넌트로 분리해야 합니다(<code class=\"language-text\">useLazyLoadQuery</code>가 이를 가능하게 합니다).</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">The Guild is <a href=\"https://the-guild.dev/blog/unleash-the-power-of-fragments-with-graphql-codegen\" title=\"https://the-guild.dev/blog/unleash-the-power-of-fragments-with-graphql-codegen\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">working on</a> bringing these ideas to other libraries.<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">서로 다른 꽃의 화분이 벌이나 나비에 의해 옮겨져서 새로운 수정이 일어나는 걸 뜻한다. 전혀 다른 그룹이 만나 교류하고, 기존에 없던 결과물들을 만드는 것을 의미함.<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-3\">For example, here is <a href=\"https://shopify.dev/docs/api/admin-rest/2023-07/resources/order#get-orders?status=any\" title=\"https://shopify.dev/docs/api/admin-rest/2023-07/resources/order#get-orders?status=any\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Shopify’s order retrieval API</a>. They went to pains to add a <code class=\"language-text\">fields</code> parameter so you can specify a comma-delimited list of fields to fetch. But, some of the fields, like <code class=\"language-text\">client_details</code>, have fields nested below it. You can’t filter those. So even when a REST API goes out of its way to add some level of filtering, it still isn’t going to make it possible to arbitrarily filter perfectly, because then the API’s ergonomics increasingly suffer (and at some point you’re just reinventing an ad-hoc GraphQL endpoint). Back when REST APIs were all that there was, in my experience internal/private REST APIs rarely even had a “fields” parameter and over-fetching was extremely prevalent.<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-4\">얻고자 하는 데이터를 가지고 있지 않은 파일들을 읽지 않고 스킵하는 형태의 최적화<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-5\"><em>Static</em> analysis has a hard time with this because GraphQL has abstract types for many fields, and those references could theoretically be tracked across your codebase, but the leaf fields are always primitive types (like <code class=\"language-text\">string</code> and <code class=\"language-text\">number</code>) and tracking references to primitive values across an entire codebase, across all code boundaries, is not a problem anyone has solved (to my knowledge). That said, <em>runtime</em> analysis using JS <code class=\"language-text\">Proxy</code> can be used to detect what fields go unused with some level of accuracy. <a href=\"https://www.reddit.com/r/RedditEng/comments/x0rasj/identifying_unused_fields_in_graphql/\" title=\"https://www.reddit.com/r/RedditEng/comments/x0rasj/identifying_unused_fields_in_graphql/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Reddit Engineering wrote about it here</a>. Runtime analysis is better than nothing, but strictly worse than just getting it exactly right at compile time.<a href=\"#fnref-5\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-6\">Relay’s cache is <a href=\"https://relay.dev/docs/principles-and-architecture/runtime-architecture/#data-model\" title=\"https://relay.dev/docs/principles-and-architecture/runtime-architecture/#data-model\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">a normalized, in-memory object graph</a>.<a href=\"#fnref-6\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-7\">My GraphQL server rejects queries with unused query variables. <a href=\"#fnref-7\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-8\">초기단계에서의 노력이 나중에 긍정적인 영향을 미칠 수 있다는 의미<a href=\"#fnref-8\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-9\">상대적으로 적은 인기를 누리는 다양한 항목들의 집합<a href=\"#fnref-9\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-10\">By locking down your API to exactly what your UI needs you’re engaging in “defense in depth” security. This shouldn’t be your main mechanism for hiding sensitive/private data that you don’t want clients to see, but not letting users make arbitrary queries against your backend is a reasonable security precaution.<a href=\"#fnref-10\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-11\">Don’t worry, Relay’s compiler <a href=\"https://relay.dev/blog/2021/12/08/introducing-the-new-relay-compiler/\" title=\"https://relay.dev/blog/2021/12/08/introducing-the-new-relay-compiler/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">is written in Rust</a>.<a href=\"#fnref-11\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-12\">It might be neat if <code class=\"language-text\">useRefetchableFragment</code> took a <code class=\"language-text\">refetchPolicy</code> argument. Maybe? <a href=\"#fnref-12\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","fields":{"slug":"/relay-style-graphql/"},"frontmatter":{"title":"(번역) Relay-style GraphQL","date":"2023-10-20","lastUpdated":"2023-10-20","description":"GraphQL을 Relay-style로 사용했을 때의 이점에 대해 상세하게 설명하는 글입니다. 원문 https://alan.norbauer.com/articles/relay-style-graphql 저자의 동의를 받고 한국어로 번역했습니다.","tags":["React","GraphQL"]}},"previous":{"fields":{"slug":"/typescript-phantom-type/"},"frontmatter":{"title":"타입스크립트 - 팬텀 타입이란 무엇인가"}},"next":{"fields":{"slug":"/storybook/"},"frontmatter":{"title":""}}},"pageContext":{"id":"fc9eae14-9844-5be6-84bf-5f482ef36b37","previousPostId":"72c86462-8237-5f53-8f93-7eec2d1b3187","nextPostId":"6b4355e4-ba1f-5b58-b176-26c60577d70b","ogImage":"public/og-image/relay-style-graphql/index.png"}},"staticQueryHashes":["2260143708","658623446","984448874"]}