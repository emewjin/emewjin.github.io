{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/til/",
    "result": {"data":{"site":{"siteMetadata":{"title":"emewjin.log","siteUrl":"https://emewjin.github.io","thumbnail":"/thumbnails/zzal.jpg"}},"markdownRemark":{"id":"2b74ed6e-e3d3-5fa3-ab17-78940ef0abb2","tableOfContents":"<ul>\n<li><a href=\"#220705\">220705</a></li>\n<li><a href=\"#220707\">220707</a></li>\n<li><a href=\"#220711\">220711</a></li>\n<li><a href=\"#220712\">220712</a></li>\n<li><a href=\"#220713\">220713</a></li>\n</ul>","excerpt":"220705 import path 단축하기 프로젝트 구성 모노레포 별도 환경설정에 소모하는 시간을 줄일 수 있음 디자인 시스템과 같이 실시간으로 보면서 개발해야하는 특수한 경우 훨씬 간편하게 watch…","html":"<h2 id=\"220705\" style=\"position:relative;\"><a href=\"#220705\" aria-label=\"220705 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>220705</h2>\n<p><strong>import path 단축하기</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// package.json</span>\n\n<span class=\"token string-property property\">\"baseUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\".\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token string-property property\">\"paths\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string-property property\">\"@libs/*\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"libs/*\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// usage</span>\n<span class=\"token keyword\">import</span> something <span class=\"token keyword\">from</span> <span class=\"token string\">'@libs/server/handler'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>프로젝트 구성</strong></p>\n<ul>\n<li>모노레포\n<ul>\n<li>별도 환경설정에 소모하는 시간을 줄일 수 있음</li>\n<li>디자인 시스템과 같이 실시간으로 보면서 개발해야하는 특수한 경우 훨씬 간편하게 watch를 걸고 빌드할 수 있음.</li>\n<li>팀 간의 작업 현황에 관심을 가질 수 있음. 커밋 기록 등등으로. 눈에 보이니 PR참여도 쉬워짐.</li>\n<li>팀마다의 커밋 기록이 섞여 지저분해짐 (히스토리 파악 어려워짐)</li>\n<li>팀마다의 테스트서버 QA / 배포 프로세스가 꼬일 수 있음. 단독으로 관리하기 어려움.</li>\n<li>공통 모듈에 수정이 가해질 경우 모든 팀의 프로젝트가 다 배포되어야 함.</li>\n</ul>\n</li>\n<li>단독 레포\n<ul>\n<li>팀마다의 단독 개발 환경 (테스트, 배포)을 구축할 수 있음</li>\n<li>공통 모듈에 수정이 가해진다 해도 필요한 팀에서만 버전을 올려 사용하고 배포하면 됨.</li>\n<li>히스토리를 깔끔하게 관리할 수 있음</li>\n<li>디자인 시스템, 이메일 템플릿과 같은 공통 모듈이지만 단독으로 관리되는 경우 실시간 수정하기 매우 귀찮음.</li>\n<li>초기 구축 비용이 소모됨</li>\n<li>다른 팀의 현황에 관심을 갖기 힘들 수 있음 (눈에서 멀어지므로)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"220707\" style=\"position:relative;\"><a href=\"#220707\" aria-label=\"220707 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>220707</h2>\n<p><strong>써드파티 라이브러리에 대해 인터페이스를 만들자는 의견</strong></p>\n<ul>\n<li>인터페이스 자체가 변화가 적고 표준이 확실한 경우, 매우 유용할 것 같다.\n<ul>\n<li>예시: http client, api interface 등</li>\n</ul>\n</li>\n<li>하지만 그렇지 않은 경우 인터페이스를 만드는 것이 오히려 독이 될 수 있을 것 같다.\n<ul>\n<li>변화가 잦고 인터페이스의 공통화가 쉽지 않은 라이브러리</li>\n<li>해결하고 싶은 문제는 같지만 해결방법이 각기 다른 라이브러리</li>\n<li>승리한 해결방법이 명확히 없는 영역</li>\n<li>예시 : 상태관리, 폼 관리 등등</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// get.js</span>\n<span class=\"token keyword\">import</span> first <span class=\"token keyword\">from</span> <span class=\"token string\">'first'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> get <span class=\"token operator\">=</span> first<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span> get <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// usage</span>\n<span class=\"token function\">get</span><span class=\"token punctuation\">(</span>successFn<span class=\"token punctuation\">,</span> objectData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 몇 달 뒤...</span>\n<span class=\"token comment\">// get.js</span>\n<span class=\"token keyword\">import</span> something <span class=\"token keyword\">from</span> <span class=\"token string\">'something'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 의도: 라이브러리 교체를 위해 인터페이스에서만 변경 발생하게 하는 것.</span>\n<span class=\"token keyword\">const</span> get <span class=\"token operator\">=</span> something<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span> get <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// usage</span>\n<span class=\"token comment\">// 근데 교체한 라이브러리의 함수가 받는 인자가 완전히 달라진다면?</span>\n<span class=\"token function\">get</span><span class=\"token punctuation\">(</span>FailFn<span class=\"token punctuation\">,</span> arrayData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 인터페이스를 만들어둔다 해도 인자 같은 것이 완전히 변하면, 결국 get 사용처를 수정해야 하는 것 아닌가? 즉, 인터페이스가 무의미해지는 것 아닌가?<br>\n이럴땐 어떻게 하는걸까?</p>\n<p><strong>Kent C의 테스트 코드 스터디 : 테스트 코드에 있어 리버스 엔지니어링</strong></p>\n<ul>\n<li>통합 테스트를 한다는 건 내부의 로직을 모르는 상황에서 테스트를 하는 것인데, 이 과정을 리버스 엔지니어링이라고 본걸까?</li>\n<li>내부 로직이 어떻게 동작하는지 알고 있기 때문에 작성할 수 있는 테스트 방식이 아닐까?</li>\n<li>특별한 장점은 없는 것 같다.</li>\n<li>감추고 싶은 부분(private)을 테스트하는 것이라 오히려 별로인듯.</li>\n</ul>\n<h2 id=\"220711\" style=\"position:relative;\"><a href=\"#220711\" aria-label=\"220711 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>220711</h2>\n<p>프로젝트 설계 &#x26; 구성을 시작했다.<br>\n모노레포 vs 멀티레포 중 당장의 빠른 개발을 위해 모노레포를 선택했는데 git 전략이 문제였다.</p>\n<p><strong>Git 브랜치 전략</strong></p>\n<p>conflict는 문제가 되지 않는다. 왜냐하면 turborepo로 filter 할 거라서.<br>\n그런데, turborepo는 git이 아니다.<br>\n모노레포를 위한 도구가 git과 배포에 밀접하게 연관되는 게 과연 괜찮은가?</p>\n<ol>\n<li>main, dev, feature, release, hotfix 로 구성된 전략\n<ul>\n<li>가장 익숙한 모델이다</li>\n<li>main에 반영되는 커밋은 곧바로 운영에 배포되고, dev에 반영되는 커밋은 곧바로 개발 서버에 배포된다.</li>\n<li>dev를 main에 넣을 땐 release를 따서 버저닝 하여 넣는다.</li>\n<li>hotfix가 필요할 땐 main에서 따서 pr merge 후 로컬에선 dev에 리베이스하여 반영한다.</li>\n<li>한 레포에 한 프로젝트 (팀)일 때 적용하기 쉬운 전략이다</li>\n<li>한 레포에 여러 프로젝트 (팀)이라면, 5개의 브랜치를 관리하는 것이 어려울 수 있다.</li>\n</ul>\n</li>\n<li>main, feature로만 구성된 전략\n<ul>\n<li>사실 내게는 낯선 모델이다</li>\n<li>빠른 배포를 목적으로 한다</li>\n<li>main에서 feature를 따서 개발, qa 후 곧바로 main에 넣어 운영배포한다.</li>\n<li>feature가 나와있는 기간이 길수록 conflict가 발생할 확률이 높아지므로 빠르게 머지하는 것이 중요하다.</li>\n<li>qa를 하려면 개발 서버가 필요한데 (dev 또는 test) 해당 브랜치가 main과 완전히 동기화 되지 않음이 걱정된다.</li>\n<li>관리해야하는 브랜치의 수가 적어 모노레포 환경에서 덜 혼란스러울 수 있다.</li>\n</ul>\n</li>\n</ol>\n<p>현재 우리 팀의 상황을 살펴보면</p>\n<ul>\n<li>운영 오픈된 프로젝트 1개, 이제 막 새롭게 개발 시작하는 프로젝트 3개.</li>\n<li>3개는 초기 단계라 모든 것이 빠르게 변하고 진행되기 때문에 버저닝이 필요하지 않다. (기획단의 요구도 없음)</li>\n<li>총 3팀, 6명이 한 레포 안에서 (모노레포) 작업을 진행한다.</li>\n<li>이전 서비스 개발시 여러 작업자가 존재할 경우 dev에서의 qa와 main으로의 배포 과정에서 고초를 겪었던 경험이 있다.</li>\n</ul>\n<p>결론: 빠르게 시도하고 실패하고 개선하자.</p>\n<p><strong>Git merge 전략</strong></p>\n<p>현재의 github에서는 세 가지의 merge를 제공하고 있다.<br>\n우리 팀에서는 어떤 전략을 채택할지에 대해 논의했는데, 전제는 “1. merge 전 rebase 수행 2. 커밋 메세지를 상세히 작성할 것”이다.</p>\n<ol>\n<li>merge commit\n<ul>\n<li>일반적으로 아는 그 머지이다.</li>\n<li>머지 커밋이 생성된다. 이 점이 지저분해지기에 맘에 안듦.</li>\n<li>모든 커밋을 보존한다.</li>\n</ul>\n</li>\n<li>squash merge\n<ul>\n<li>여러 커밋이 하나의 대왕 커밋으로 퉁쳐지기 때문에 히스토리가 보존되지 않는다는 단점이 있다.</li>\n<li>commit revert 할 때 하나의 커밋만 하면 된다는 장점이 있다.</li>\n<li>커밋 내역이 commit body로 남고, 상세 커밋별 파일 체인지를 보고 싶다면 해당 피알 링크를 눌러 이동해 보면 되긴 하지만 모든 pr마다 다 이동해서 봐야한다는 귀찮은 단점이 있다.</li>\n<li>github의 스쿼시 머지는 머지 커밋이 남지 않아 깔끔하다.</li>\n<li>dev(또는 main) 기준에서 jira의 한 티켓 당 하나의 커밋만이 쌓이는 것이기 때문에 그래프가 깔끔할 수 있다.</li>\n</ul>\n</li>\n<li>rebase merge\n<ul>\n<li>커밋을 squash 하지 않으면서도 머지 커밋이 생성되지 않는다.</li>\n<li>머지 커밋 없이 티켓 번호 prefix만 보고 구분해야 한다.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"220712\" style=\"position:relative;\"><a href=\"#220712\" aria-label=\"220712 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>220712</h2>\n<p><a href=\"https://emewjin.github.io/typeguard/#%ED%83%80%EC%9E%85%EA%B0%80%EB%93%9C-%EC%82%AC%EB%A1%80-2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">타입가드</a></p>\n<h2 id=\"220713\" style=\"position:relative;\"><a href=\"#220713\" aria-label=\"220713 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>220713</h2>\n<p>vite로 react-ts 프로젝트를 생성해서 개발하고 있는데, 환경변수에 따라 특정 모듈을 import할지 결정할 수 있어야 했다.<br>\n왜냐하면 local 이외의 환경에선 번들에 특정 모듈을 포함하고 싶지 않았기 때문임. 단순히 rollup의 설정으로 특정 디렉토리의 특정 파일을 번들링시 제외하는 옵션만으로는 해당 모듈을 import하는 곳에서 에러가 발생할 수도 있기 때문에, 아예 조건에 따라 import하지 않음으로 해결하고자 했다.<br>\n그러기 위해서 이걸 이렇게 쓰는게 맞는지는 모르겠으나 <code class=\"language-text\">React.lazy</code>를 이용해 환경변수를 조건으로 import하는 코드를 작성했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">OnlyDevComponent</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>importPath<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n  <span class=\"token comment\">// eslint-disable-next-line @typescript-eslint/ban-ts-comment</span>\n  <span class=\"token comment\">// @ts-ignore</span>\n  React<span class=\"token punctuation\">.</span><span class=\"token function\">lazy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> isLocalhost <span class=\"token operator\">=</span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">.</span>meta<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">MODE</span> <span class=\"token operator\">===</span> <span class=\"token string\">'localhost'</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isLocalhost<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// eslint-disable-next-line @typescript-eslint/no-unsafe-return</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span>importPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>ts-ignore부터 린트룰 비활성화까지… 좋은 형태는 아닌 것 같지만 일단 목적하는 바는 달성했다.</p>","fields":{"slug":"/til/"},"frontmatter":{"title":"Today I Learned","date":"2022-07-05","lastUpdated":"2022-07-13","description":"작고 사소한 개발 지식","tags":["Typescript"],"thumbnail":null}},"previous":{"fields":{"slug":"/uxui/"},"frontmatter":{"title":"프론트엔드 개발자의 UX/UI 위키"}},"next":{"fields":{"slug":"/typeguard/"},"frontmatter":{"title":"타입가드"}}},"pageContext":{"id":"2b74ed6e-e3d3-5fa3-ab17-78940ef0abb2","previousPostId":"fc2e4b98-3011-5b6f-a978-e7912cbbb987","nextPostId":"fc06637a-e92a-5c4f-af5f-6b41fb208f73"}},
    "staticQueryHashes": ["2260143708","658623446","984448874"]}