{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/til/",
    "result": {"data":{"site":{"siteMetadata":{"title":"emewjin.log","siteUrl":"https://emewjin.github.io","thumbnail":"/thumbnails/zzal.jpg"}},"markdownRemark":{"id":"2b74ed6e-e3d3-5fa3-ab17-78940ef0abb2","tableOfContents":"<ul>\n<li><a href=\"#220705\">220705</a></li>\n<li><a href=\"#220707\">220707</a></li>\n</ul>","excerpt":"220705 import path 단축하기 프로젝트 구성 모노레포 별도 환경설정에 소모하는 시간을 줄일 수 있음 디자인 시스템과 같이 실시간으로 보면서 개발해야하는 특수한 경우 훨씬 간편하게 watch…","html":"<h2 id=\"220705\" style=\"position:relative;\"><a href=\"#220705\" aria-label=\"220705 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>220705</h2>\n<p><strong>import path 단축하기</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// package.json</span>\n\n<span class=\"token string-property property\">\"baseUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\".\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token string-property property\">\"paths\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string-property property\">\"@libs/*\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"libs/*\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// usage</span>\n<span class=\"token keyword\">import</span> something <span class=\"token keyword\">from</span> <span class=\"token string\">'@libs/server/handler'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>프로젝트 구성</strong></p>\n<ul>\n<li>모노레포\n<ul>\n<li>별도 환경설정에 소모하는 시간을 줄일 수 있음</li>\n<li>디자인 시스템과 같이 실시간으로 보면서 개발해야하는 특수한 경우 훨씬 간편하게 watch를 걸고 빌드할 수 있음.</li>\n<li>팀 간의 작업 현황에 관심을 가질 수 있음. 커밋 기록 등등으로. 눈에 보이니 PR참여도 쉬워짐.</li>\n<li>팀마다의 커밋 기록이 섞여 지저분해짐 (히스토리 파악 어려워짐)</li>\n<li>팀마다의 테스트서버 QA / 배포 프로세스가 꼬일 수 있음. 단독으로 관리하기 어려움.</li>\n<li>공통 모듈에 수정이 가해질 경우 모든 팀의 프로젝트가 다 배포되어야 함.</li>\n</ul>\n</li>\n<li>단독 레포\n<ul>\n<li>팀마다의 단독 개발 환경 (테스트, 배포)을 구축할 수 있음</li>\n<li>공통 모듈에 수정이 가해진다 해도 필요한 팀에서만 버전을 올려 사용하고 배포하면 됨.</li>\n<li>히스토리를 깔끔하게 관리할 수 있음</li>\n<li>디자인 시스템, 이메일 템플릿과 같은 공통 모듈이지만 단독으로 관리되는 경우 실시간 수정하기 매우 귀찮음.</li>\n<li>초기 구축 비용이 소모됨</li>\n<li>다른 팀의 현황에 관심을 갖기 힘들 수 있음 (눈에서 멀어지므로)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"220707\" style=\"position:relative;\"><a href=\"#220707\" aria-label=\"220707 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>220707</h2>\n<p><strong>써드파티 라이브러리에 대해 인터페이스를 만들자는 의견</strong></p>\n<ul>\n<li>인터페이스 자체가 변화가 적고 표준이 확실한 경우, 매우 유용할 것 같다.\n<ul>\n<li>예시: http client, api interface 등</li>\n</ul>\n</li>\n<li>하지만 그렇지 않은 경우 인터페이스를 만드는 것이 오히려 독이 될 수 있을 것 같다.\n<ul>\n<li>변화가 잦고 인터페이스의 공통화가 쉽지 않은 라이브러리</li>\n<li>해결하고 싶은 문제는 같지만 해결방법이 각기 다른 라이브러리</li>\n<li>승리한 해결방법이 명확히 없는 영역</li>\n<li>예시 : 상태관리, 폼 관리 등등</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// get.js</span>\n<span class=\"token keyword\">import</span> first <span class=\"token keyword\">from</span> <span class=\"token string\">'first'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> get <span class=\"token operator\">=</span> first<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span> get <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// usage</span>\n<span class=\"token function\">get</span><span class=\"token punctuation\">(</span>successFn<span class=\"token punctuation\">,</span> objectData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 몇 달 뒤...</span>\n<span class=\"token comment\">// get.js</span>\n<span class=\"token keyword\">import</span> something <span class=\"token keyword\">from</span> <span class=\"token string\">'something'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 의도: 라이브러리 교체를 위해 인터페이스에서만 변경 발생하게 하는 것.</span>\n<span class=\"token keyword\">const</span> get <span class=\"token operator\">=</span> something<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span> get <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// usage</span>\n<span class=\"token comment\">// 근데 교체한 라이브러리의 함수가 받는 인자가 완전히 달라진다면?</span>\n<span class=\"token function\">get</span><span class=\"token punctuation\">(</span>FailFn<span class=\"token punctuation\">,</span> arrayData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 인터페이스를 만들어둔다 해도 인자 같은 것이 완전히 변하면, 결국 get 사용처를 수정해야 하는 것 아닌가? 즉, 인터페이스가 무의미해지는 것 아닌가?<br>\n이럴땐 어떻게 하는걸까?</p>\n<p><strong>Kent C의 테스트 코드 스터디 : 테스트 코드에 있어 리버스 엔지니어링</strong></p>\n<ul>\n<li>통합 테스트를 한다는 건 내부의 로직을 모르는 상황에서 테스트를 하는 것인데, 이 과정을 리버스 엔지니어링이라고 본걸까?</li>\n<li>내부 로직이 어떻게 동작하는지 알고 있기 때문에 작성할 수 있는 테스트 방식이 아닐까?</li>\n<li>특별한 장점은 없는 것 같다.</li>\n<li>감추고 싶은 부분(private)을 테스트하는 것이라 오히려 별로인듯.</li>\n</ul>","fields":{"slug":"/til/"},"frontmatter":{"title":"Today I Learned","date":"2022-07-05","lastUpdated":"2022-07-07","description":"작고 사소한 개발 지식","tags":["Typescript"],"thumbnail":null}},"previous":{"fields":{"slug":"/uxui/"},"frontmatter":{"title":"프론트엔드 개발자의 UX/UI 위키"}},"next":{"fields":{"slug":"/storybook/"},"frontmatter":{"title":""}}},"pageContext":{"id":"2b74ed6e-e3d3-5fa3-ab17-78940ef0abb2","previousPostId":"fc2e4b98-3011-5b6f-a978-e7912cbbb987","nextPostId":"6b4355e4-ba1f-5b58-b176-26c60577d70b"}},
    "staticQueryHashes": ["2260143708","658623446","984448874"]}