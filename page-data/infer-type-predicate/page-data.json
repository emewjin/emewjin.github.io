{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/infer-type-predicate/","result":{"data":{"site":{"siteMetadata":{"title":"emewjin.log","siteUrl":"https://emewjin.github.io"}},"markdownRemark":{"id":"1d07bf5a-4adc-5283-822a-f41790078591","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D\">작동 방식</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%84%B1%EA%B3%BC\">성과</a></p>\n<ul>\n<li><a href=\"#%EC%95%9E%EC%9C%BC%EB%A1%9C-%ED%83%80%EC%9E%85-%EA%B0%80%EB%93%9C%EB%8A%94-%ED%9D%90%EB%A6%85%EB%8B%88%EB%8B%A4\">앞으로 타입 가드는 흐릅니다.</a></li>\n<li><a href=\"#truthy-%EA%B0%92%EC%97%90-%EC%9D%98%ED%95%9C-%EC%9E%A0%EC%9E%AC%EC%A0%81%EC%9D%B8-%EB%AC%B8%EC%A0%9Ctruthiness-footguns%EB%A5%BC-%ED%94%BC%ED%95%A0-%EC%88%98-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4\">truthy 값에 의한 잠재적인 문제(truthiness footguns)를 피할 수 있습니다.</a></li>\n<li><a href=\"#%ED%83%80%EC%9E%85-%EA%B0%80%EB%93%9C%EB%A5%BC-%EB%8D%94-%EC%89%BD%EA%B2%8C-%EC%B0%BE%EC%9D%84-%EC%88%98-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4\">타입 가드를 더 쉽게 찾을 수 있습니다.</a></li>\n<li><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%97%90%EC%84%9C-%EC%B6%94%EB%A1%A0%EB%90%9C-%ED%83%80%EC%9E%85-%EA%B0%80%EB%93%9C%EA%B0%80-%ED%99%95%EC%9D%B8%EB%90%A9%EB%8B%88%EB%8B%A4\">인터페이스에서 추론된 타입 가드가 확인됩니다.</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%9D%A5%EB%AF%B8%EB%A1%9C%EC%9A%B4-%EC%82%AC%EB%A1%80%EB%93%A4\">흥미로운 사례들</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B8%B0%EC%A1%B4-%EC%BD%94%EB%93%9C%EA%B0%80-%EA%B9%A8%EC%A7%80%EB%8A%94-%EC%82%AC%EB%A1%80\">기존 코드가 깨지는 사례</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%84%B1%EB%8A%A5\">성능</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%99%95%EC%9E%A5-%EA%B0%80%EB%8A%A5%EC%84%B1\">확장 가능성</a></p>\n</li>\n</ul>","excerpt":"원문: Infer type predicates from function bodies using control flow analysis #16069 해결 #38390 해결 #10734 해결 #50734 해결 #12798 해결 이 PR…","html":"<blockquote>\n<p>원문: <a href=\"https://github.com/microsoft/TypeScript/pull/57465\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Infer type predicates from function bodies using control flow analysis</a></p>\n</blockquote>\n<p><a href=\"https://github.com/microsoft/TypeScript/issues/16069\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">#16069</a> 해결<br>\n<a href=\"https://github.com/microsoft/TypeScript/issues/38390\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">#38390</a> 해결<br>\n<a href=\"https://github.com/microsoft/TypeScript/issues/10734\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">#10734</a> 해결<br>\n<a href=\"https://github.com/microsoft/TypeScript/issues/50734\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">#50734</a> 해결<br>\n<a href=\"https://github.com/microsoft/TypeScript/issues/12798\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">#12798</a> 해결</p>\n<p>이 PR은 타입스크립트의 기존 제어 흐름 분석을 사용하여 적절한 곳에서 불리언(boolean) 값을 반환하는 함수에 대한 타입 서술어(type predicates)를 추론합니다. 예를 들면 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">isString</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 함수는 현재 버전에서는 <code class=\"language-text\">boolean</code>에 대한 추론된 반환 타입을 가지고 있지만 이 PR이 적용된다면 타입 서술어가 됩니다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 700px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/50c1163aba44b8393bf740a010869b5e/307e7/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 20.571428571428573%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAuklEQVQY032LyW6EMBTA+P8/rGbtoMIkeWR5YaAJEFc9VOqlteSDD+6g8eOcK5MrBF/QFNHgiF6IMZHmmaCZpIqNioSIaibGBa8ZScq2bXTrApphWRvWTpxPhsspYJ6Gfuy59e8MRjiPlusoGBd4uImnTASfcPaFC4kP8ZRa6V75wLztyGXncc/crsowWJ5WiD5i7j1JJmReWMvBcfAvXSmNVhvsjVKgFmjfuW2w77TyyVHrr6XR2t9+Aa9FNH9DmAeWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1\"\n        title=\"1\"\n        src=\"/static/50c1163aba44b8393bf740a010869b5e/8c557/1.png\"\n        srcset=\"/static/50c1163aba44b8393bf740a010869b5e/4edbd/1.png 175w,\n/static/50c1163aba44b8393bf740a010869b5e/13ae7/1.png 350w,\n/static/50c1163aba44b8393bf740a010869b5e/8c557/1.png 700w,\n/static/50c1163aba44b8393bf740a010869b5e/e996b/1.png 1050w,\n/static/50c1163aba44b8393bf740a010869b5e/307e7/1.png 1354w\"\n        sizes=\"(max-width: 700px) 100vw, 700px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>저는 7년 전(!) <a href=\"https://github.com/microsoft/TypeScript/issues/16069\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">#16069</a> 이슈를 작성했는데, 이를 해결해 보면 재미있을 것 같았습니다. 생각보다 더 깔끔하고 간단하게 해결할 수 있었습니다. 새로운 함수 하나에 약 65줄의 코드 정도만 추가되었습니다. 이것은 좋은 성과라고 생각합니다!</p>\n<h2 id=\"작동-방식\" style=\"position:relative;\"><a href=\"#%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D\" aria-label=\"작동 방식 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>작동 방식</h2>\n<p>타입 가드를 추론할 수 있는 함수 후보의 조건은 다음과 같습니다.</p>\n<ol>\n<li>명시적인 반환 타입이나 타입 서술어가 없어야 합니다.</li>\n<li>추론된 반환 타입이 불리언이어야 합니다.</li>\n<li>하나의 <code class=\"language-text\">return</code> 문이 있어야 하며 암시적인 반환이 없어야 합니다 (나중에 느슨해질 수 있습니다).</li>\n<li>매개변수를 변형하지 않아야 합니다.</li>\n</ol>\n<p>이 조건을 만족한다면, 함수는 다음과 같은 형태를 가질 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> p2<span class=\"token operator\">:</span> <span class=\"token constant\">T2</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">return</span> expr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 PR에서는 각 매개변수에 대해, 함수가 다음과 같다고 가정할 때 각 분기에서의 흐름에 따라 타입을 결정합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> p2<span class=\"token operator\">:</span> <span class=\"token constant\">T2</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>expr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    p1<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// trueType</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>만약 <code class=\"language-text\">trueType != T</code>라면, 타입 서술어 <em>후보</em> 를 갖게 됩니다.</p>\n<p>그러나 타입 서술어의 의미 때문에 <code class=\"language-text\">false</code> 반환 값이 무엇을 의미하는지 확인해야 합니다. 다음과 같은 코드가 있다고 해봅시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">declare</span> <span class=\"token keyword\">function</span> <span class=\"token function\">isString</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> x <span class=\"token keyword\">is</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 함수가 <code class=\"language-text\">true</code>를 반환하면 <code class=\"language-text\">x</code>는 <code class=\"language-text\">string</code>입니다. 그러나 <code class=\"language-text\">false</code>를 반환하면 <code class=\"language-text\">x</code>는 <em>반드시</em> <code class=\"language-text\">number</code>여야 합니다. 다시 말하자면, 타입 서술어가 되려면, 함수는 서술어가 <em>성립할 때만</em> <code class=\"language-text\">true</code>를 반환해야 합니다.</p>\n<p>우리는 합성된 <code class=\"language-text\">if</code>문에 <code class=\"language-text\">trueType</code>을 대입하고 <code class=\"language-text\">else</code> 분기에 무엇이 남아있는지 확인하여 직접 테스트할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">:</span> trueType<span class=\"token punctuation\">,</span> p2<span class=\"token operator\">:</span> <span class=\"token constant\">T2</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>expr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    p1<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// trueType</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    p1<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// never?</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>만약 이것이 <code class=\"language-text\">never</code>라면 “only if” 조건을 증명한 것입니다.</p>\n<p>이 PR의 이전 버전은 약간 다른 검사를 수행했음을 참고하세요. 원래 버전은 <a href=\"https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1957867140\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">하위 형식(subtypes)에 문제</a>가 있었고 초기 수정은 필요 이상으로 <code class=\"language-text\">getFlowTypeOfReference</code>를 더 많이 호출했습니다. 이 버전은 우리가 원하는 조건을 직접 테스트합니다.</p>\n<h2 id=\"성과\" style=\"position:relative;\"><a href=\"#%EC%84%B1%EA%B3%BC\" aria-label=\"성과 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>성과</h2>\n<p>이제 타입스크립트는 <code class=\"language-text\">filter</code> 호출과 같이 편리한 여러 곳에서 타입 가드를 추론할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> nums <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'foo'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">23</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'bar'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//    ^? const nums: number[]</span></code></pre></div>\n<p>이는 기존의 flow type 코드의 장점을 활용하기 때문에 타입스크립트가 이해할 수 있는 모든 형태의 타입 좁히기가 가능합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> foos <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> x <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Foo</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//    ^? const foos: Foo[]</span></code></pre></div>\n<p>그 외에도 몇 가지 뜻밖의 성과들이 있습니다.</p>\n<h3 id=\"앞으로-타입-가드는-흐릅니다\" style=\"position:relative;\"><a href=\"#%EC%95%9E%EC%9C%BC%EB%A1%9C-%ED%83%80%EC%9E%85-%EA%B0%80%EB%93%9C%EB%8A%94-%ED%9D%90%EB%A6%85%EB%8B%88%EB%8B%A4\" aria-label=\"앞으로 타입 가드는 흐릅니다 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>앞으로 타입 가드는 흐릅니다.</h3>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> isString <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>o<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> o <span class=\"token keyword\">is</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=></span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>o<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// - (o: string | undefined) => boolean</span>\n<span class=\"token comment\">// + (o: string | undefined) => o is string</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">secondIsString</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>o<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">myGuard</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>새로운 방식으로도 결합될 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// const isFooBar: (x: unknown) => x is Foo | Bar</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">isFooBar</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">isFoo</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token function\">isBar</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"truthy-값에-의한-잠재적인-문제truthiness-footguns를-피할-수-있습니다\" style=\"position:relative;\"><a href=\"#truthy-%EA%B0%92%EC%97%90-%EC%9D%98%ED%95%9C-%EC%9E%A0%EC%9E%AC%EC%A0%81%EC%9D%B8-%EB%AC%B8%EC%A0%9Ctruthiness-footguns%EB%A5%BC-%ED%94%BC%ED%95%A0-%EC%88%98-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\"truthy 값에 의한 잠재적인 문제truthiness footguns를 피할 수 있습니다 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>truthy 값에 의한 잠재적인 문제(truthiness footguns)를 피할 수 있습니다.</h3>\n<p>만약 <code class=\"language-text\">truthy</code>한지를 확인하는 경우에는 타입 가드를 추론하지 않습니다. 단지 null이 아님을 확인하는 경우에만 추론합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> numsTruthy <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//    ^? const numsTruthy: (number | null)[]</span>\n<span class=\"token keyword\">const</span> numsNonNull <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//    ^? const numsNonNull: number[]</span></code></pre></div>\n<p>이렇게 하는 이유는 <code class=\"language-text\">false</code>인 경우 때문입니다. 만약 <code class=\"language-text\">truthy</code>한지를 확인해서 <code class=\"language-text\">false</code>를 반환하면, <code class=\"language-text\">x</code>는 <code class=\"language-text\">0</code>이 될 수 있습니다. 타입스크립트가 “0 이외의 숫자”를 나타낼 수 있거나, <code class=\"language-text\">true</code>와 <code class=\"language-text\">false</code>에 해당하는 경우에 대해 구분된 타입 서술어를 반환할 수 있는 방법이 없다면, <code class=\"language-text\">truthy</code>한지를 확인하는 것에서 추론할 수 있는 것은 없습니다.</p>\n<p>반면에, 객체 타입을 다루는 경우 잠재적인 문제가 없으며, <code class=\"language-text\">truthy</code>한지 확인하는 것으로 서술어를 추론합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> datesTruthy <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//    ^? const datesTruthy: Date[]</span></code></pre></div>\n<p>이는 그럴 필요가 있는 곳에서 <code class=\"language-text\">truthy</code>한지를 확인하는 것 대신 <code class=\"language-text\">null</code>이 아닌지 확인하도록 유도하므로 저는 이것 또한 성과라고 생각합니다. 특히 원래 이슈의 예제는 <code class=\"language-text\">null</code>이 아닌지 확인하는 것 대신 <code class=\"language-text\">truthy</code>한지를 테스트합니다.</p>\n<h3 id=\"타입-가드를-더-쉽게-찾을-수-있습니다\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85-%EA%B0%80%EB%93%9C%EB%A5%BC-%EB%8D%94-%EC%89%BD%EA%B2%8C-%EC%B0%BE%EC%9D%84-%EC%88%98-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\"타입 가드를 더 쉽게 찾을 수 있습니다 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입 가드를 더 쉽게 찾을 수 있습니다.</h3>\n<p>타입 서술어는 매우 유용한 기능이지만, 문서를 읽거나 선언 파일에서 타입 가드를 볼 때만 알 수 있습니다. 이제 자신의 코드에서 심볼을 검사함으로써 타입 서술어를 찾을 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">isString</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//     ^? const isString: (x: unknown) => x is string</span></code></pre></div>\n<p>이것은 언어의 일부인 것처럼 느끼게 만듭니다.</p>\n<h3 id=\"인터페이스에서-추론된-타입-가드가-확인됩니다\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%97%90%EC%84%9C-%EC%B6%94%EB%A1%A0%EB%90%9C-%ED%83%80%EC%9E%85-%EA%B0%80%EB%93%9C%EA%B0%80-%ED%99%95%EC%9D%B8%EB%90%A9%EB%8B%88%EB%8B%A4\" aria-label=\"인터페이스에서 추론된 타입 가드가 확인됩니다 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터페이스에서 추론된 타입 가드가 확인됩니다.</h3>\n<p>이 PR은 명시적인 타입 서술어를 우선하지만, 이런 경우에는 추론된 서술어도 확인할 것입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">NumberInferrer</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">isNumber</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> x <span class=\"token keyword\">is</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Inferrer</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">NumberInferrer</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">isNumber</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 이것도 확인됩니다!!!</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"흥미로운-사례들\" style=\"position:relative;\"><a href=\"#%ED%9D%A5%EB%AF%B8%EB%A1%9C%EC%9A%B4-%EC%82%AC%EB%A1%80%EB%93%A4\" aria-label=\"흥미로운 사례들 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>흥미로운 사례들</h2>\n<p>이론상으로, 불리언 값에 대한 항등 함수(identity function)는 타입 가드입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// boolId: (b: boolean): b is true?</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">boolId</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> b<span class=\"token punctuation\">;</span></code></pre></div>\n<p>이런 방식은 정확해 보이지만 그다지 유용하지 않습니다. 왜 직접 불리언을 테스트하지 않을까요? 저는 이 PR에서 특히 불리언 매개변수에 대한 타입 서술어 추론을 명시적으로 금지했습니다. 이것만으로도 diff 수를 상당히 줄일 수 있습니다.</p>\n<p>여기 또 다른 흥미로운 사례가 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">flakyIsString</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span> <span class=\"token operator\">&amp;&amp;</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 함수가 <code class=\"language-text\">true</code>을 반환하면 <code class=\"language-text\">x</code>는 <code class=\"language-text\">string</code>입니다. 그러나 <code class=\"language-text\">false</code>를 반환하면 <code class=\"language-text\">x</code>는 여전히 <code class=\"language-text\">string</code>일 수 있습니다. 따라서 이 경우 타입 서술어를 추론하는 것은 유효하지 않습니다. 이것이 바로 <code class=\"language-text\">trueType</code>을 확인할 수 없는 이유입니다. 일반적으로 이와 같은 조건을 결합하면 타입 서술어를 추론할 수 없습니다. 함수가 참과 거짓의 경우에 대해 서로 다른 타입 서술어를 반환하는 방법이 있으면 좋을 것 같습니다(<a href=\"https://github.com/microsoft/TypeScript/issues/15048\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">#15048</a>). 이렇게 하면 추론이 훨씬 더 강력해질 것입니다. 그러나 그것은 더 큰 변화일 것입니다.</p>\n<p>RyanC<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>가 타입 시스템에서 함수의 반환 타입은 그 구현을 다시 말하는 것이 되어서는 안 된다고 말한 적이 있습니다. 어떤 경우에는 이런 방향으로 움직이는 것처럼 느껴질 수도 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// function hasAB(x: unknown): x is object &amp; Record&lt;\"a\", unknown> &amp; Record&lt;\"b\", unknown></span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">hasAB</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token string\">'a'</span> <span class=\"token keyword\">in</span> x <span class=\"token operator\">&amp;&amp;</span> <span class=\"token string\">'b'</span> <span class=\"token keyword\">in</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>다른 함수와 마찬가지로 타입 가드는 선언된 매개변수 타입의 하위 타입으로 호출될 수 있습니다. 타입 가드를 추론할 때 이 점을 고려해야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">isShortString</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span> <span class=\"token operator\">&amp;&amp;</span> x<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 문제는 <code class=\"language-text\">if</code> / <code class=\"language-text\">else</code>에서 이 검사를 인라인하면 <code class=\"language-text\">x</code>가 <code class=\"language-text\">string</code>과 <code class=\"language-text\">unknown</code>으로 좁혀지고 <code class=\"language-text\">Exclude&lt;unknown, string> = unknown</code>이 된다는 것입니다. 그러나 여기서 타입 서술어를 추론할 수는 없습니다. 왜냐하면 <code class=\"language-text\">isShortString</code>이 <code class=\"language-text\">string</code>으로 호출될 수 있기 때문입니다. 이것은 원래 이 PR에서 사용되었던 테스트를 깨뜨렸습니다 (<a href=\"https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1957751656\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">이 코멘트</a>를 참조하세요).</p>\n<p>함수는 어썰션을 통해 <code class=\"language-text\">return</code>에 도달하기 전에 매개변수 타입을 좁힐 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">assertAndPredicate</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">|</span> Date<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 <code class=\"language-text\">x is string</code>을 추론하는 것은 잘못된 것은 아니지만 <code class=\"language-text\">else</code> 분기에는 (<code class=\"language-text\">Date</code>를 포함한) 부정확한 타입이 생성될 것입니다. 이 PR은 이런 경우 <code class=\"language-text\">getFlowTypeOfReference</code>를 추가 호출하는 비용을 지불하고 타입 서술어를 추론하지 않음으로써 안전하게 처리합니다.</p>\n<h2 id=\"기존-코드가-깨지는-사례\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EC%A1%B4-%EC%BD%94%EB%93%9C%EA%B0%80-%EA%B9%A8%EC%A7%80%EB%8A%94-%EC%82%AC%EB%A1%80\" aria-label=\"기존 코드가 깨지는 사례 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기존 코드가 깨지는 사례</h2>\n<p>기존 코드의 새로운 오류는 대부분 <a href=\"https://github.com/microsoft/TypeScript/issues/38390#issuecomment-626019466\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">#38390 (comment)</a>의 다소 정교한 변형입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'foo'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'bar'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\na<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 지금은 괜찮지만 이 PR에서는 에러가 발생합니다.</span></code></pre></div>\n<p>다시 말해, 이 PR을 사용하면 TS가 배열이나 기타 변수에 대해 타입을 좁혀 추론한 다음 더 넓은 타입이 필요한 작업(푸시, 재할당, <code class=\"language-text\">indexOf</code> 호출)을 수행할 수 있습니다. @typescript-bot과 제가 발견한 변경 사항에 대한 자세한 내용은 <a href=\"https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1960271216\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">이 댓글</a>을 참조하세요.</p>\n<h2 id=\"성능\" style=\"position:relative;\"><a href=\"#%EC%84%B1%EB%8A%A5\" aria-label=\"성능 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>성능</h2>\n<p>타입 서술어를 추론하기 위해 추가 작업을 수행하고 있으므로 성능은 확실히 우려되는 부분입니다. @typescript-bot은 Compiler-Unions에서 검사 시간이 +1.25% 증가하는 중대한 속도 저하를 <a href=\"https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1964484345\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">발견</a>했습니다.</p>\n<p>속도 저하의 일부는 <code class=\"language-text\">getTypePredicateFromBody</code>에서 수행되는 (제가 추가한) 추가 작업으로 인한 것이지만, 일부는 새로 감지된 타입 가드 덕분에 타입스크립트가 더 많은 위치에서 더 정확한 타입을 추론하고 있기 때문이기도 합니다.</p>\n<p>현재 구현에 성능 문제가 있는 경우 범위를 줄일 수 있는 몇 가지 옵션이 있습니다.</p>\n<ul>\n<li>화살표 함수에서만 실행</li>\n<li>문맥적으로 타입이 지정된 화살표 함수에서만 실행</li>\n<li>타입 서술어를 사용할 문맥에서 문맥적으로 타입이 지정된 화살표 함수에서만 실행 (예: <code class=\"language-text\">Array.prototype.filter</code>)</li>\n</ul>\n<h2 id=\"확장-가능성\" style=\"position:relative;\"><a href=\"#%ED%99%95%EC%9E%A5-%EA%B0%80%EB%8A%A5%EC%84%B1\" aria-label=\"확장 가능성 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확장 가능성</h2>\n<p>이 PR의 범위에서 제외하기로 한 몇 가지 확장 가능한 사항들이 있습니다.</p>\n<ul>\n<li>명시적 타입 서술어 확인. 이 PR은 명시적 타입 서술어를 당장은 사용하지 않지만 대신 검사하는 것을 상상할 수는 있습니다. 이렇게 하면 현재로서는 타입 어썰션보다 안전하다고 할 수 없는 사용자 정의 타입 가드에 약간의 타입 안전성을 가져올 수 있습니다.</li>\n<li>어썰션 함수 추론. 불리언을 반환하는 대신 던지는 경우 유사한 형태의 추론을 수행할 수 있어야 합니다.</li>\n<li>만약 <a href=\"https://github.com/microsoft/TypeScript/issues/15048\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">이 제안(일방적 또는 세분화된 타입 가드)</a>이 구현된다면, 훨씬 더 많은 상황에서 타입 서술어를 추론할 수 있습니다.</li>\n<li><code class=\"language-text\">this</code>에 대한 타입 서술어 추론. 불리언을 반환하는 메서드가 <code class=\"language-text\">this</code> 서술어가 될 수 있습니다. 이것은 이 PR의 간단한 확장일 것입니다.</li>\n<li><code class=\"language-text\">boolean</code> 이외의 값을 반환하는 함수에 대한 타입 서술어 추론. 만약 <code class=\"language-text\">dates</code>가 <code class=\"language-text\">(Date|null)[]</code>이라면 <code class=\"language-text\">dates.filter(d => d)</code>는 <code class=\"language-text\">null</code>을 필터링하는 좋은 방법입니다. 이 PR은 <code class=\"language-text\">dates.filter(d => !!d)</code>를 작성하게 합니다. 이는 일반적으로 타입 서술어의 한계이지 이 PR의 한계가 아니라고 생각합니다.</li>\n<li>다중 반환 처리. 예를 들어, 이 함수에 대한 타입 가드를 추론하는 것은 가능할 테지만 더 많은 작업이 필요할 것입니다.\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">isString</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> x <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<blockquote>\n<p>🚀 한국어로 된 프런트엔드 아티클을 빠르게 받아보고 싶다면 <a href=\"https://kofearticle.substack.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Korean FE Article</a>을 구독해주세요!</p>\n</blockquote>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">(역) <a href=\"https://github.com/RyanCavanaugh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">타입스크립트 팀 Development lead</a><a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>","fields":{"slug":"/infer-type-predicate/"},"frontmatter":{"title":"(번역) 제어 흐름 분석을 통해 함수 내부로부터 타입 서술어 추론하기","date":"2024-03-23","lastUpdated":"2024-03-23","description":"최근 타입스크립트에 제어 흐름 분석을 통해 타입 서술어를 추론하게 하는 PR이 병합되었습니다. PR에 의하면 filter 메서드 등을 사용시 타입 추론에 어려움을 겪었던 부분이 해결될 수 있을 것으로 기대되어 PR 내용을 번역해 소개해 드립니다.","tags":["Typescript","번역"]}},"previous":{"fields":{"slug":"/safetest/"},"frontmatter":{"title":"(번역) 프런트엔드 테스트에 대한 새로운 접근 방식 SafeTest를 소개합니다"}},"next":null},"pageContext":{"id":"1d07bf5a-4adc-5283-822a-f41790078591","previousPostId":"fa5af294-b13e-545b-ada4-e82df304810d","nextPostId":null,"ogImage":"public/og-image/infer-type-predicate/index.png"}},"staticQueryHashes":["2260143708","984448874"]}