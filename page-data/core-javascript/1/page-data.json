{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/core-javascript/1/",
    "result": {"data":{"site":{"siteMetadata":{"title":"emewjin.log","siteUrl":"https://emewjin.github.io","thumbnail":"/thumbnails/zzal.jpg"}},"markdownRemark":{"id":"8e540dc1-c897-5dc6-8ed2-3878d3bb8aa0","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85\">자바스크립트의 데이터 타입</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%84%A0%ED%96%89-%EA%B0%9C%EB%85%90-1-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0\">선행 개념 1. 메모리와 데이터</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%84%A0%ED%96%89-%EA%B0%9C%EB%85%90-2-%EC%8B%9D%EB%B3%84%EC%9E%90%EC%99%80-%EB%B3%80%EC%88%98\">선행 개념 2. 식별자와 변수</a></p>\n<ul>\n<li><a href=\"#%EB%B3%80%EC%88%98%EC%9D%98-%EC%84%A0%EC%96%B8-%EA%B3%BC%EC%A0%95\">변수의 선언 과정</a></li>\n<li><a href=\"#%EB%B3%80%EC%88%98%EC%9D%98-%ED%95%A0%EB%8B%B9-%EA%B3%BC%EC%A0%95\">변수의 할당 과정</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%B6%88%EB%B3%80%EA%B0%92\">불변값</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EC%A1%B0%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%ED%95%A0%EB%8B%B9-%EA%B3%BC%EC%A0%95\">참조형 데이터의 할당 과정</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC\">얕은 복사와 깊은 복사</a></p>\n</li>\n<li>\n<p><a href=\"#undefined%EC%99%80-null\">undefined와 null</a></p>\n</li>\n</ul>","excerpt":"…","html":"<blockquote>\n<p>📖 이 글은 코어자바스크립트를 읽고 책을 바탕으로 이해한 내용을 작성한 글입니다.</p>\n</blockquote>\n<p>세 건의 프로젝트를 통해 자바스크립트를 이용한 웹 프론트엔드 개발 경험을 쌓으며 <strong>지금 당장 자바스크립트에 대해 무엇을 공부해야할지</strong> 알 수 있었습니다. 하지만 프로젝트 마감 일정 등이 빡빡한 탓에.. 이론적인 부분은 나중으로 미루며 우선 프로젝트를 잘 마무리하는 데에 집중했었어요.</p>\n<p>이제는 세 건의 프로젝트가 모두 종료된 만큼 (리팩토링이 진행 중이긴 하지만..) To Do 리스트로만 쌓여져 있던 ‘공부할 자바스크립트 이론들’을 하나씩 공부하고 있습니다. 그 일환으로 <strong>코어자바스크립트</strong> 책을 다시 읽으면서 이해한 것을 정리해보려고 합니다. <strong>1장, 데이터 타입</strong>을 읽고 해소할 수 있었던 의문점들은 다음과 같습니다.</p>\n<ul>\n<li>undefined가 아니라 null을 이용해야 하는 이유</li>\n<li>리액트 등 spa 프레임워크에서 state의 불변성을 유지해야하는 이유</li>\n<li>얕은 복사와 깊은 복사</li>\n<li>참조형 데이터란 무엇인가</li>\n</ul>\n<h2 id=\"자바스크립트의-데이터-타입\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85\" aria-label=\"자바스크립트의 데이터 타입 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바스크립트의 데이터 타입</h2>\n<p>자바스크립트를 처음 공부할 때 자바스크립트에는 두 가지의 데이터 타입이 있다고 배웠었습니다. 첫 번째가 기본형(원시형, Primitive type)이고 두 번째가 참조형(Reference type)이예요.</p>\n<ul>\n<li>기본형 : number, string, null, undefined, boolean, symbol</li>\n<li>참조형 : object, array, function, date, regexp, map, set 등</li>\n</ul>\n<p>그때는 그냥 <code class=\"language-text\">그런가보다~</code>하고 넘어갔었지만, 이제는 저게 뭔지 좀 더 깊이 알아야 궁금했던 부분들을 해결할 수 있었습니다. 코어자바스크립트에 의하면 엄밀하게 자바스크립트의 모든 데이터는 참조형이라고 할 수 있는데, 이게 무슨 말인지는 뒤에서 더 이야기 해보겠습니다.</p>\n<p>기본형과 참조형을 나누는 기준으로 흔히 두 가지를 이야기해요. 첫째가 ’<strong>불변성</strong>‘이고 둘째가 ‘실제값’들로 연결시켜주는 ‘주소값’들이 모여있는 주소를 복제하는지, ‘실제값’이 담긴 주소를 바로 복제하는지입니다.</p>\n<p>이게 무슨 말인지 이해하려면 먼저 메모리와 데이터에 대해 간단하게나마 이해해야 하고, 식별자와 변수를 구분할 수 있어야 합니다. 하나씩 되짚어보겠습니다.</p>\n<h2 id=\"선행-개념-1-메모리와-데이터\" style=\"position:relative;\"><a href=\"#%EC%84%A0%ED%96%89-%EA%B0%9C%EB%85%90-1-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0\" aria-label=\"선행 개념 1 메모리와 데이터 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선행 개념 1. 메모리와 데이터</h2>\n<p>컴퓨터의 <strong>메모리</strong>는 매우 많은 <strong>비트</strong>들로 구성되어 있어요. 비트란 0 또는 1로만 표현이 가능한 메모리 조각입니다. 그리고 고유한 식별자를 통해 비트의 위치를 찾아갈 수 있습니다. 그렇지만 이건 매우 비효율적인 일입니다. 생각해보면, 비트는 0 또는 1로만, 즉 두 가지의 경우로만 표현이 가능하다 했습니다. 이렇게 한정적인 표현으로 수 많은 데이터의 위치를 표현하기엔 너무 빡쎄단 생각이 들죠.</p>\n<p>모든 기술은 이전 기술의 불편함 또는 문제를 해결하기 위해 등장한다 했습니다. 이런 비트의 문제를 해결하기 위해서 비트 여러개를 묶어서 하나의 단위로 여기기 시작했어요. 그러면서 표현할 수 있는 값이 증가하고, 검색 시간이 감소했어요. 하지만 장점만 있지는 않았습니다. <strong>낭비되는 비트</strong>가 생기게 된 것입니다.</p>\n<p>따라서, <strong>바이트</strong>가 등장했습니다.<br>\n표현 가능한 개수에 어느 정도 제약을 걸더라도, 비트의 낭비를 최소화하기로 한 거예요. 그 적정선이 바로 8개의 비트를 묶어서 256개의 값을 표현할 수 있는 바이트였습니다. 바이트 역시 <strong>비트의 식별자</strong>로 위치를 파악합니다. 이 비트의 식별자란, <strong>메모리 주소값</strong>을 의미합니다. 결국 모든 데이터는 바이트 단위의 식별자로 서로 구분하고 연결할 수 있게 됩니다.</p>\n<p>그런데, 애초에 저런 고민은 메모리가 넉넉하지 않았으니까 했을거예요. 하지만 자바스크립트가 등장하던 시점에는 이전에 비해 메모리가 많이 넉넉해졌습니다. 따라서 자바스크립트는 상대적으로 메모리 관리 압박에서 자유로워져서, 넉넉한 메모리를 할당하게 됩니다.</p>\n<h2 id=\"선행-개념-2-식별자와-변수\" style=\"position:relative;\"><a href=\"#%EC%84%A0%ED%96%89-%EA%B0%9C%EB%85%90-2-%EC%8B%9D%EB%B3%84%EC%9E%90%EC%99%80-%EB%B3%80%EC%88%98\" aria-label=\"선행 개념 2 식별자와 변수 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선행 개념 2. 식별자와 변수</h2>\n<p>모든 데이터는 바이트 단위의 식별자로 서로 구분하고 연결한다고 했습니다. 식별자란 메모리 주소값을 의미한다고 했고요. 그러면 식별자와 변수는 같은 걸까요 다른 걸까요?</p>\n<p>식별자와 변수는 쉽게 혼용되지만 실제로 다른 개념입니다. <strong>변수</strong>가 변할 수 있는 수, 변할 수 있는 <strong>데이터</strong>를 의미한다면 <strong>식별자</strong>는 어떤 데이터를 식별하는 데 사용되는 <strong>이름</strong>입니다. 즉, 변수의 이름 (변수명)인거죠. 변수가 데이터를 저장하는 곳이라면, 식별자(변수명)는 데이터를 저장하는 곳의 이름입니다. 데이터를 저장한 곳을 찾아갈 수 있게 해주는 이름이요.</p>\n<ul>\n<li>변수 : 데이터를 저장하는 곳. 변할 수 있는 데이터를 의미</li>\n<li>식별자 : 데이터를 저장한 곳의 이름. 데이터를 저장한 곳을 찾아갈 수 있게 (=데이터를 식별할 수 있게) 함.</li>\n</ul>\n<p>둘이 다르다는 것은 이제 알겠습니다. 그러면 실제로 어떻게 쓰이고 있을까요 ? 변수의 선언 과정을 살펴보면 알 수 있습니다.</p>\n<h3 id=\"변수의-선언-과정\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EC%88%98%EC%9D%98-%EC%84%A0%EC%96%B8-%EA%B3%BC%EC%A0%95\" aria-label=\"변수의 선언 과정 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변수의 선언 과정</h3>\n<p><code class=\"language-text\">var a = 3</code>이라는 식은 선언과 할당이 동시에 이루어지는 식입니다. 이 식을 입력하면 자바스크립트는 메모리에서 임의의 주소값에 공간을 찜합니다. 그리고 공간에 변수의 이름과 데이터를 저장합니다. 다음과 같은 구조를 띈다고 할 수 있어요. 데이터 부분은 사실 저게 아니지만, 지금은 간단하게 표현하려고 저렇게 썼다고 봐주세요.</p>\n<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/76927618/127830253-278a8b91-818a-40dd-bb98-71e3ba692e36.jpg\" alt=\"예시1\" width=\"500px\">\n</p>\n<p>이후 메모리에서 a이름을 가진 주소값을 검색합니다. 여기서 식별자가 변수를 찾을 수 있는 이름이라고 했던 게 무슨 말인지 알 수 있어요. 그리고 해당 주소값의 공간에 담긴 데이터를 반환합니다.</p>\n<h3 id=\"변수의-할당-과정\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EC%88%98%EC%9D%98-%ED%95%A0%EB%8B%B9-%EA%B3%BC%EC%A0%95\" aria-label=\"변수의 할당 과정 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변수의 할당 과정</h3>\n<p>그럼 이번에는 변수의 할당 과정만 살펴보겠습니다. 위에서 선언했던 <code class=\"language-text\">var a = 3</code>을, <code class=\"language-text\">a = 5</code>라고 재할당합니다. 그러면 먼저 a라는 이름을 가진 주소값을 찾을 거라는 건 이제 알고 있습니다. 그리고, 그 공간에 데이터 5를 저장할 거라고 생각할 수 있지만 실제로 그렇게 직접 저장하지 않습니다.</p>\n<p>직접 저장하는 것이 아니라 <strong>별도의 메모리 공간을 다시 확보</strong>하고, 새 공간에 데이터를 저장한 후, 그 새 공간의 주소를 변수 영역의 데이터에 저장하게 됩니다.</p>\n<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/76927618/127830246-d99ad7bd-0d24-4ef3-8347-34a7e2306406.jpg\" alt=\"예시2\" width=\"500px\">\n</p>\n<p>이렇게 굳이 한 단계를 더 거치는 이유는 뭘까요? 그냥 원래 있던 변수 영역의 데이터에 덮어씌우기 하면 편할 것 같은데요. 그 이유는 두 가지입니다.</p>\n<ul>\n<li>데이터 변환을 자유롭게 하기 위해서</li>\n<li>메모리 관리를 더 효율적으로 하기 위해서 (중복 데이터에 대한 처리 효율 증가)</li>\n</ul>\n<p>이게 무슨 말일까요?</p>\n<p>string 값을 할당했다고 해보겠습니다. 처음 문자열의 길이는 짧았고 자바스크립트는 그 크기에 맞춰 메모리의 영역을 찜해놨어요. 그리고 그 이후에 다른 데이터들이 줄줄이 뒤에 저장되었죠. 그런데 이제와서 string 값의 길이가 늘어나게 된거예요. 이러면 공간을 더 늘려야 합니다. 늘려야 하는데 이미 뒤에가 꽉 찼어요. 뒤에 있는 데이터들을 늘어난 길이만큼 뒤로 밀거나 해야겠죠. 이 과정에서 연산이 많이 발생하게 됩니다.</p>\n<p>이런 문제를 해결하기 위해서, 효율적으로 메모리를 관리하기 위해서 변수와 데이터를 분리하여 별도의 공간에 저장하는 것입니다. 얼마나 효율적일지 알아보기 위해 책의 예시를 인용하겠습니다.</p>\n<p>변수와 데이터가 분리되어있지 않는다면 500개의 공간에 숫자를 다 넣어줘야됩니다. 숫자 5가 8바이트라 할때, 4000바이트의 메모리 소모가 발생합니다.</p>\n<p>반면 변수와 데이터가 분리되어 있다면 500개의 공간을 찜하는 것은 똑같지만 그 공간들에 숫자를 일일이 다 넣어주지 않아도 됩니다. 숫자 5가 저장된 데이터 영역의 주소값만 넣어줍니다. 이미 존재하는 5를 재활용하는거죠. 변수와 데이터가 분리되어 있기에 가능한 일입니다.</p>\n<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/76927618/127830240-72fea9d7-eae7-4e97-82a2-258fa1103688.jpg\" alt=\"예시3\" width=\"500px\">\n</p>\n<p>그래서 주소값이 2바이트라고 하면, 8바이트의 숫자 5를 한 번 저장하는 것까지 해서 총 1008바이트의 메모리 소모가 발생합니다. 차이가 크다는 것을 바로 알 수 있습니다.</p>\n<p><strong>결론</strong><br>\n변수에 데이터를 재할당할 때에는 원래 자리에 값을 덮어씌우는 것이 아니라 <strong>무조건 새로 만들어서</strong> 별도의 공간에 저장한다 !</p>\n<h2 id=\"불변값\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%B3%80%EA%B0%92\" aria-label=\"불변값 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불변값</h2>\n<p>이제 우리는 변수와 데이터를 <strong>각각의 영역으로 분리</strong>하여 관리하고, 변수 영역에는 <strong>데이터 영역의 주소값</strong>이 변수명(식별자)과 함께 저장된다는 사실을 알았습니다.</p>\n<p>그럼 이제 궁금한 게 하나 생겨요. 한 번 데이터 할당이 이루어진 변수 영역에, 다른 데이터를 <strong>재할당</strong> 할 수 있을까요? 그러니까, 1003번 주소값에 a라는 이름과 5005번 데이터가 할당되어 있을 때 5005번을 5008번으로 바꿀 수 있을까요?</p>\n<p>이게 가능한 것을 <strong>변수</strong>라고 하고, 불가능한 것을 <strong>상수</strong>라고 합니다. 즉, 변수와 상수를 구분하는 것은 <strong>변수 영역의 메모리</strong>입니다. 변수 영역에 다른 데이터를 재할당할 수 있냐는거죠.</p>\n<p>변수와 상수의 뜻을 알고나니 상수가 불변값과 같은 말로 보이기도 하는 것 같지만, 둘은 다릅니다. <strong>불변값</strong>의 변경 가능성은 상수와 달리 <strong>데이터 영역</strong>을 기준으로 하기 때문입니다.</p>\n<p>예시를 보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token string\">'abc'</span><span class=\"token punctuation\">;</span>\na <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> <span class=\"token string\">'def'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이런 식이 있을 때, 1003번 주소의 영역에 이름은 a, 데이터는 5001번 주소값이 할당됩니다. 그리고 5001번 주소의 영역에는 ‘abc’가 저장됩니다. <strong>이 ‘abc’를 변경할 수 있냐 없냐</strong>가 바로 불변값이냐 아니냐를 판단하는 기준이 됩니다. 상수는 5001번을 변경할 수 있냐 없냐를 기준으로 하는 거였죠.</p>\n<p>우리는 위에서, 변수에 데이터를 재할당 할 때에는 무조건 새로 만들어서 별도의 공간에 저장한다고 했습니다. 따라서 5001번의 데이터 영역은 바뀌지 않고 그대로고, 5002번 데이터 영역이 새로 생겨 ‘abcdef’가 저장될 것임을 알 수 있습니다. 실제로 구조를 간단히 그려보면 다음과 같습니다.</p>\n<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/76927618/127831833-b766f0f2-93b4-4222-9ef1-664ff985d1da.jpg\" alt=\"예시4\" width=\"500px\">\n</p>\n<p>결론적으로 5001번이 바뀌지 않았죠? 5002번과 완전히 다른 데이터입니다. 이를 <strong>불변값</strong>이라고 합니다.</p>\n<p>즉, <strong>불변값의 특징</strong>은 다음과 같습니다.</p>\n<ul>\n<li>변경은 새로 만드는 동작을 통해서만 이루어진다</li>\n<li>한번 만들어진 것은 가비지 컬렉팅을 제외하면 영원히 변하지 않는다.</li>\n</ul>\n<p>이러니까 또 하나 궁금한 게 생깁니다. ‘그럼 만들어졌는데 아무데서도 안 쓰이는 경우는 낭비아닌가?’ 이 궁금증은 <strong>가비지 컬렉팅</strong>이 해결해줍니다. 참조하는 곳이 없다면 (= 참조카운트가 0이라면) 가비지 컬렉팅이 수거해갑니다. 이렇게 낭비되는 메모리가 없도록 관리를 해요.</p>\n<p>어쨌든 다시 돌아와서, 이제 불변값이 뭔지 알았습니다. 그럼 떠오르는 게 하나 있죠. 맨 처음에 우리는 기본형과 참조형의 차이 중 하나가 ‘불변성’이라고 했었습니다. 기본형은 불변값이지만 참조형은 불변값이 아니고 가변값이라고요. 참조형은 뭐 어떻게 돌아가길래 불변값이 아닌 걸까요?</p>\n<h2 id=\"참조형-데이터의-할당-과정\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%ED%95%A0%EB%8B%B9-%EA%B3%BC%EC%A0%95\" aria-label=\"참조형 데이터의 할당 과정 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조형 데이터의 할당 과정</h2>\n<p>참조형 데이터의 할당 과정도 기본형 데이터와 크게 다르지 않습니다. 딱 하나 결정적인 차이는, <strong>객체의 프로퍼티가 저장되는 영역이 별도로 존재</strong>한다는 겁니다.</p>\n<p>객체의 프로퍼티에 각각의 값이 할당된 것이므로, 프로퍼티를 변수로 취급하여 변수영역에 저장하고 그 값은 데이터 영역에서 관리합니다. 따라서 프로퍼티에 할당된 값도 예외없이 이미 데이터 영역에 존재하는지를 확인함으로써 효율적으로 메모리를 관리하죠.</p>\n<p>그리고 프로퍼티가 일종의 <code class=\"language-text\">변수'</code> 영역으로 관리되기 때문에 역시 주소값이 저장되는 데이터가 변할 수 있는, <strong>가변값</strong>임을 알 수 있습니다. 이게 <strong>참조형 데이터는 불변하지 않다고 이야기하는 이유</strong>입니다.</p>\n<p>즉, 다음과 같은 식은 이렇게 구조를 그려 이해해볼 수 있습니다. <code class=\"language-text\">obj.a = 2</code>라고 하면 5007 대신 5009 주소가 연결됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">a</span><span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">b</span><span class=\"token operator\">:</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> obj<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/76927618/127833511-8e6a015b-33ce-4ec4-a600-1f9e9f8715de.jpg\" alt=\"예시5\" width=\"500px\">\n</p>\n<p>그런데 참조형은 언제나 가변값일까요? 정답은 ‘아니오’입니다. 참조형 데이터가 가변값이라고 하는 것은 참조형 데이터 자체에 새 것을 할당하는 게 아니라, <strong>그 내부 프로퍼티를 변경하려 할 때</strong> 해당하는 이야기입니다. 다음의 예시를 통해서 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> obj1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">a</span><span class=\"token operator\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">b</span><span class=\"token operator\">:</span> <span class=\"token string\">'ddd'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> obj2 <span class=\"token operator\">=</span> obj1<span class=\"token punctuation\">;</span>\n\nobj2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">a</span><span class=\"token operator\">:</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">b</span><span class=\"token operator\">:</span> <span class=\"token string\">'ddd'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/76927618/127835641-a2242135-7add-482d-a95c-e2ca215ddf67.jpg\" alt=\"예시6\" width=\"500px\">\n</p>\n<p>이렇게 <strong>객체 자체를 재할당</strong>한다면 원본 객체는 그대로 유지되고, 메모리에는 새 객체가 저장됩니다. 이 부분을 이용해 <strong>참조형 데이터를 불변 객체로</strong> 만들 수 있습니다.</p>\n<p>SPA 프레임워크를 이용할 때 state 객체의 불변성을 유지하는 것이 중요하다라는 이야기를 눈 따갑게 보셨을 텐데요, 그 이유는 효율적인 렌더링을 위해 이전 state와 이후 state를 비교해야 하는데, 불변성을 지키지 않으면 이전 state를 추적할 수 없기 때문입니다. 이전 객체까지 같이 변해버리니까요.</p>\n<p>이처럼 불변객체는 <strong>값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 할 때</strong> 사용됩니다.</p>\n<h2 id=\"얕은-복사와-깊은-복사\" style=\"position:relative;\"><a href=\"#%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC\" aria-label=\"얕은 복사와 깊은 복사 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>얕은 복사와 깊은 복사</h2>\n<p>이제 불변값이 무슨 의미인지 알고, 참조형과 기본형의 차이도 명확히 알게 되었습니다. 그럼 더 나아가서, 우리가 그동안 눈 따갑게 보았었던 참조형을 복사할 때의 주의점의 의미를 다시 생각해 볼 수 있습니다. 기본형은 그냥 복사할 수 있지만, 참조형은 복사할 때 불변성을 유지하지 않으면 수정시 원래의 값까지 같이 변한다는 그 주의점이요.</p>\n<p>변수를 복사할 때, 기본형과 참조형 <strong>모두 같은 주소를 바라보게 된다</strong>는 점에서는 동일합니다. 그래서 엄밀히 말하자면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수밖에 없다고 코어자바스크립트의 저자가 이야기하는 것이구요.</p>\n<p>하지만 두 타입은 이미 <strong>할당 과정에서 큰 차이</strong>가 있었습니다. 기본형은 주소값을 복사하는 과정이 한 번만 일어나지만 참조형은 한 단계를 더 거치죠. 그러므로, 복사 이후의 동작에서도 큰 차이가 발생하게 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> obj1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">a</span><span class=\"token operator\">:</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">b</span><span class=\"token operator\">:</span> <span class=\"token string\">'abc'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> obj2 <span class=\"token operator\">=</span> obj1<span class=\"token punctuation\">;</span>\nobj2<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> <span class=\"token string\">'2'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj1<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2</span></code></pre></div>\n<p>이런 불상사가 일어나는 것을 막기 위해 참조형 데이터는 이렇게 복사해야 한다! 하면서 얕은 복사와 깊은 복사가 소개됩니다.</p>\n<ul>\n<li>얕은 복사 : 바로 아래 단계 값만 복사. 참조형 데이터 프로퍼티 복사시 그 주소값만 복사하는 것.</li>\n<li>깊은 복사 : 내부의 모든 단계를 하나하나 찾아서 전부 복사. 불변 객체를 만드는 과정을 재귀적으로 수행해 내부 프로퍼티들도 전부 불변 객체로 만든다.</li>\n</ul>\n<h2 id=\"undefined와-null\" style=\"position:relative;\"><a href=\"#undefined%EC%99%80-null\" aria-label=\"undefined와 null permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>undefined와 null</h2>\n<p>마지막으로, 너무나도 비슷해보이는 두 데이터 타입의 차이에 대해 알아봅니다. <code class=\"language-text\">vue 2.x</code>를 이용해 프로젝트를 할 때, 상위 컴포넌트에서 전달받은 prop의 데이터 타입을 확인하는 식을 작성할 일이 있었습니다. 그런데, 애초에 값이 없는 채로 넘어오는 prop의 경우 그 타입을 <code class=\"language-text\">undefined</code>로 해야할지 <code class=\"language-text\">null</code>로 해야할지 고민이 됐었어요. 왜냐면 둘이 비슷한 의미니까요. 결론적으로는 <code class=\"language-text\">null</code>을 이용하는 것이 권장되었습니다.</p>\n<p>그 이유는 <code class=\"language-text\">undefined</code>에는 두 가지 종류가 있기 때문이예요.</p>\n<ul>\n<li>자바스크립트 엔진이 자동으로 지정한 <code class=\"language-text\">undefined</code></li>\n<li>사용자가 의도적으로 입력한 <code class=\"language-text\">undefined</code></li>\n</ul>\n<p>같은 <code class=\"language-text\">undefined</code>같지만 둘은 실제로 다르고, 구분됩니다. 장난하냐 싶지만 실제로 달라요. 1번은 <code class=\"language-text\">진짜로 값 없음 ;;;</code>이고, 2번은 <code class=\"language-text\">없긴 한데 실존하는 데이터임ㅎ</code>이예요. 둘의 차이는 객체를 순회할 때 아주 명확해집니다.</p>\n<p>객체의 순회에서, 1번의 경우에는 프로퍼티 또는 배열의 인덱스 자체가 존재하지 않음을 의미하는 것이기 때문에 에러가 발생하지만 2번의 경우는 어쨌건 할당은 된 것이라 프로퍼티 또는 배열의 인덱스가 존재하므로, 객체의 순회가 가능합니다.</p>\n<p>이처럼 둘은 혼란을 야기하기 때문에, <code class=\"language-text\">null</code>이 등장해서 2번을 대체합니다. 이러면 <code class=\"language-text\">undefined</code>는 1의 의미로만 쓰이기 때문에 혼란을 막을 수 있습니다. <strong>‘값을 대입하지 않은 변수에 접근할 때 자바스크립트 엔진이 알아서 반환해주는 값’</strong> 으로만 존재할 수 있는 거죠. 왜 undefined가 아니라 null을 써야 했는지, 이제 이해가 됩니다.</p>","fields":{"slug":"/core-javascript/1/"},"frontmatter":{"title":"코어자바스크립트 - 자바스크립트의 데이터 타입","date":"2021-08-02","lastUpdated":"2021-08-02","description":"코어자바스크립트 스터디 1장","tags":["Javascript","Book"],"thumbnail":null}},"previous":{"fields":{"slug":"/211215/"},"frontmatter":{"title":"바닐라 자바스크립트로 SPA 구현해보기"}},"next":{"fields":{"slug":"/core-javascript/2/"},"frontmatter":{"title":"코어자바스크립트 - 실행 컨텍스트"}}},"pageContext":{"id":"8e540dc1-c897-5dc6-8ed2-3878d3bb8aa0","previousPostId":"ab6e2a07-3b30-5fad-a072-687fbb5d7cc1","nextPostId":"bf2fe9b2-4d63-5919-bfca-4cd48d39cad5"}},
    "staticQueryHashes": ["2260143708","658623446","984448874"]}