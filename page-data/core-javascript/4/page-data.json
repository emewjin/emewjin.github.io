{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/core-javascript/4/","result":{"data":{"site":{"siteMetadata":{"title":"emewjin.log","siteUrl":"https://emewjin.github.io","thumbnail":"/thumbnails/zzal.jpg"}},"markdownRemark":{"id":"345f5448-4536-5fae-ad8e-abe0efa16af1","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%BD%9C%EB%B0%B1%ED%95%A8%EC%88%98%EC%9D%98-%EC%A0%9C%EC%96%B4%EA%B6%8C\">콜백함수의 제어권</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%BD%9C%EB%B0%B1%ED%95%A8%EC%88%98%EB%8F%84-%ED%95%A8%EC%88%98%EB%8B%A4-\">콜백함수도 함수다 🧐</a></p>\n<ul>\n<li><a href=\"#%EA%B7%B8%EA%B2%8C-%EC%8B%AB%EC%9C%BC%EB%A9%B4-\">그게 싫으면 🤔?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%BD%9C%EB%B0%B1%ED%95%A8%EC%88%98%EB%8A%94-%EC%A7%80%EC%98%A5%EC%9D%84-%EB%A7%8C%EB%93%A0%EB%8B%A4-\">콜백함수는 지옥을 만든다 😈</a></p>\n<ul>\n<li><a href=\"#%EC%A0%84%ED%86%B5%EC%A0%81-%ED%95%B4%EA%B2%B0%EC%B1%85\">전통적 해결책</a></li>\n<li><a href=\"#promise\">Promise</a></li>\n<li><a href=\"#%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0\">제네레이터</a></li>\n<li><a href=\"#async-await\">async, await</a></li>\n</ul>\n</li>\n</ul>","excerpt":"📖 이 글은 코어자바스크립트를 읽고 책을 바탕으로 이해한 내용을 작성한 글입니다. 코어자바스크립트 4장은 앞, 뒤로 다른 장에서 다루는 내용들이 많아서인지 다른 장에 비해 쉬어가는 느낌이 있었다…가 아니라, 폭풍전야의 느낌이었다. 특히 곧 다가올…","html":"<blockquote>\n<p>📖 이 글은 코어자바스크립트를 읽고 책을 바탕으로 이해한 내용을 작성한 글입니다.</p>\n</blockquote>\n<p>코어자바스크립트 4장은 앞, 뒤로 다른 장에서 다루는 내용들이 많아서인지 다른 장에 비해 쉬어가는 느낌이 있었다…가 아니라, 폭풍전야의 느낌이었다. 특히 곧 다가올 5장이 클로저라는 무서운😈 친구여서 더욱 더.</p>\n<p>이 글에서는 책을 읽고 배운 내용을 간단하게 정리해보고 대신 콜백함수 하면 빼놓을 수 없는 Promise, async, await에 대해 톺아보려고 한다.</p>\n<h2 id=\"콜백함수의-제어권\" style=\"position:relative;\"><a href=\"#%EC%BD%9C%EB%B0%B1%ED%95%A8%EC%88%98%EC%9D%98-%EC%A0%9C%EC%96%B4%EA%B6%8C\" aria-label=\"콜백함수의 제어권 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>콜백함수의 제어권</h2>\n<p>앞서 3장 포스팅에서 콜백함수의 정의를 간략하게 이야기했었다.</p>\n<blockquote>\n<p>코어자바스크립트에서는 콜백함수란 <strong>제어권을 다른 함수에게 넘겨준 함수</strong>라고 말하고 있다. 정확하게는 함수 A의 제어권을 다른 함수(메소드 포함) B에게 넘겨주었을 때 이 A함수를 콜백함수라고 한다는 것이다. 때문에 A함수는 B함수의 내부 로직에 따라 실행되며 this도 B함수 내부 로직에 의해 결정된다. 만약 B함수에서 A함수의 this를 별도 지정한다면 그게 A함수의 this가 된다.</p>\n</blockquote>\n<p>때문에 4장에서는 콜백함수의 제어권에 대한 이야기가 주가 되었다. 로마에 가면 로마의 법을 따르라는 말처럼, 콜백함수의 제어권을 넘긴다는 것은 꽤 많은 부분 콜백함수의 제어권을 쥐고 있는 함수의 정책을 따라야 하는 것이었다.</p>\n<ul>\n<li>콜백 함수 A의 호출 시점은 함수 B가 결정한다.</li>\n<li>콜백 함수 A의 인자로 넘겨줄 값과 그 순서도 함수 B가 결정한다.</li>\n<li>콜백 함수 A의 this 또한 함수 B가 결정할 수 있다.</li>\n</ul>\n<h2 id=\"콜백함수도-함수다-\" style=\"position:relative;\"><a href=\"#%EC%BD%9C%EB%B0%B1%ED%95%A8%EC%88%98%EB%8F%84-%ED%95%A8%EC%88%98%EB%8B%A4-\" aria-label=\"콜백함수도 함수다  permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>콜백함수도 함수다 🧐</h2>\n<p>이 부분이 특히 인상깊었는데, 저자 스스로도 ‘당연한 말일 수도 있겠지만’ 하면서도 이 부분을 강조한 것은 this 때문이다. 객체의 메소드로 실행할 때와 함수로 실행할 때 this가 달라진다는 것을 3장에서 공부했었다. 때문에 콜백함수로 객체의 메소드를 넘긴다면 this가 여전히 그 객체일 것이라고 오해하기 쉽다.</p>\n<p>그러나 콜백함수는 함수이지, 객체의 메소드가 아니기 때문에 객체의 메소드를 콜백함수로 넘겼다 해도 그건 메소드가 아니라 함수로 실행된다. 즉, this를 따로 명시적 바인딩을 해주지 않는 이상 this는 전역객체를 가리키게 된다는 것이다.</p>\n<h3 id=\"그게-싫으면-\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EA%B2%8C-%EC%8B%AB%EC%9C%BC%EB%A9%B4-\" aria-label=\"그게 싫으면  permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그게 싫으면 🤔?</h3>\n<p>역시나 그게 싫은 개발자들이 여러 대안을 마련했었다.</p>\n<p>객체의 메소드를 콜백으로 넘기더라도 여전히 this가 객체를 가리키게 하고 싶다면 결국 this를 바인딩해줘야 한다. 하지만 위에서도 이야기했듯 콜백함수의 권한은 호출하는 함수가 갖는다. 때문에 원래는 개발자 마음대로 콜백함수의 this를 설정할 수 없다.</p>\n<div align=\"center\">\n<img src=\"https://t1.daumcdn.net/cfile/tistory/99A96C395C7230FC10\">\n</div>\n<p>하지만 인간은 답을 찾는다. 늘 그랬듯이. (ㅋㅋ)</p>\n<p>전통적 방식은 함수 안에서 this를 변수에 담아 그 변수를 this로 이용하는 것이다. 그후 함수를 리턴하면 클로저가 되기 때문에 this를 개발자 마음대로 설정하고 유지할 수 있다. 하지만 이 방법은 불필요하게 복잡하고 번거롭다. 메모리를 낭비시킨다는 문제도 있다 (정확하게는, 메모리 낭비는 의도한 것이지만 이는 추후 5장 클로저에서 다룰 것이다).</p>\n<p>그러나 별 대안이 없었기 때문에 계속 이용했었는데, 현재는 bind 메소드가 등장했기 때문에 이를 이용하면 쉽게 콜백함수에도 this를 설정할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">btn<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token function\">test</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"콜백함수는-지옥을-만든다-\" style=\"position:relative;\"><a href=\"#%EC%BD%9C%EB%B0%B1%ED%95%A8%EC%88%98%EB%8A%94-%EC%A7%80%EC%98%A5%EC%9D%84-%EB%A7%8C%EB%93%A0%EB%8B%A4-\" aria-label=\"콜백함수는 지옥을 만든다  permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>콜백함수는 지옥을 만든다 😈</h2>\n<p>콜백 지옥. Callback Hell.</p>\n<figure align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/76927618/129585419-29c4ab36-621e-42d2-a27b-b931c7d29154.png\">\n<figcaption>구글에 검색만 해봐도 어마무시한 코드들이 보인다</figcaption>\n</figure>\n<p>자바스크립트는 기본적으로 동기적으로 동작하지만 싱글 스레드 언어이기 때문에 수많은 비동기적 핸들링이 함께한다. 때문에 자바스크립트의 비동기 함수를 얼마나 잘 다루느냐가 관건인데, 가장 대표적으로 신경쓰는 부분이라고 한다면 역시 비동기 함수를 동기적으로 핸들링하는 것일테다.</p>\n<p>비동기 함수들을 동기적으로 다루기 위해서, 즉 실행 순서를 보장하기 위해서, 개발자가 원하는 순서에 비동기 함수의 값을 이용하기 위해서 ! 콜백 함수가 이용되어 왔었다. 하지만 이 콜백 함수로 익명함수를 계속 전달하다보니 <strong>indent가 끝도 없이 깊어져</strong> 가독성이 💩망진창이 되어버렸다. 또한, <strong>값이 전달되는 순서가 아래에서 위</strong>이므로 (가장 안쪽 콜백부터 시작될테니까), 위에서 아래로 읽는 것에 익숙한 우리 인간들은 최악의 가독성에 골머리를 앓았다.</p>\n<h3 id=\"전통적-해결책\" style=\"position:relative;\"><a href=\"#%EC%A0%84%ED%86%B5%EC%A0%81-%ED%95%B4%EA%B2%B0%EC%B1%85\" aria-label=\"전통적 해결책 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>전통적 해결책</h3>\n<p><strong>처음의 해결책</strong>은 익명함수가 아니라 기명함수를 쓰는 것이었다. 다음은 책의 예시코드이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> coffeeList <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">addEspresso</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  coffeeList <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>addAmericano<span class=\"token punctuation\">,</span> <span class=\"token number\">500</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"아메리카노\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">addAmericano</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  coffeeList <span class=\"token operator\">+=</span> <span class=\"token string\">\", \"</span> <span class=\"token operator\">+</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>addMocha<span class=\"token punctuation\">,</span> <span class=\"token number\">500</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"카페모카\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">...</span>\n\n이런식으로 계속 이어진다<span class=\"token punctuation\">.</span></code></pre></div>\n<p>기명함수를 이용해서 넘겨주고, 넘겨주고 하다보면 깊어지는 indent도 사라지고 코드를 위에서 아래로 읽을 수 있게 되었지만 썩 쿨한 방법은 아니다. 왜냐하면 불필요하게 일회성 함수를 변수에 계속 할당해야 하고, 읽을 때 <code class=\"language-text\">addAmericano</code>가 뭐지? 하고 보러가고 그런식으로 <strong>코드를 따라다녀야 해서</strong> 오히려 헷갈릴 수 있기 때문이다. (필자는 다른 상황에 같은 이유로 이건 절차지향적인 코드라 다르게 수정하는 것이 훨씬 보기 좋을 것 같다는 코드리뷰를 받은 적 있었다)</p>\n<p>다행스럽게도 이것보다 훨씬 쿨🧚🏻하게 콜백지옥을 해결해줄 수 있는 Promise와 제네레이터가 es6에서 등장했다.</p>\n<h3 id=\"promise\" style=\"position:relative;\"><a href=\"#promise\" aria-label=\"promise permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Promise</h3>\n<p>프로미스는 비동기 동작을 값으로 다룰 수 있게 <strong>도와준다</strong>.<br>\n값으로 반환하는 것이 아니라 다룰 수 있게 도와준다고 표현하는 이유는, 프로미스는 비동기 작업의 처리가 완료된 <strong>그 상태 그대로 홀딩</strong>된 객체이기 때문이다. 즉, 프로미스를 리턴받았다고 해서 그거 콘솔에 찍어보면 값이 나오지 않는다는 이야기이다. 값을 보고싶다면 소비 메소드를 사용해야 한다. 좀 더 비유해서 이야기하자면 프로미스는 비동기 작업과 개발자 사이의 연결고리이다. 개발자는 프로미스를 통해 언제 도착할지 모르는 비동기 작업을 개발자가 원하는 시점에 다룰 수 있게 된다.</p>\n<p>프로미스 객체를 만들고 그 안에 작성되는 코드는 즉시 실행되지만<sub>(그래서 조심해야 한다. 왜냐면 사용자가 요구하지도 않았는데 불필요한 네트워크 통신이 일어날 수 있기 때문이다.)</sub> 실제 그 값이 유효하게 사용되려면 프로미스가 기본적으로 갖고 있는 두 인자, resolve/reject 콜백함수를 사용해 처리하고 값을 consumer에게 넘겨줘야 한다. 이들을 이용해 성공 또는 실패 값을 뽑아내야 프로미스의 consumer(소비 메소드)인 then,catch를 이용해 개발자가 원하는 작업을 이어나갈 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  executor<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Promise가 처리할 비동기 동작 코드</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<figure align=\"center\">\n<img src=\"https://mdn.mozillademos.org/files/8633/promises.png\n\">\n</figure>\n<ul>\n<li>resolve, reject 둘 중 하나는 무조건 사용해야 consumer를 사용할 수 있다</li>\n<li>프로미스는 대기(pending), 이행(fulfilled), 거부(rejected) 셋 중 하나의 상태(state)를 가진다.</li>\n<li>이행, 거부된 상태를 처리된(settled) 프로미스라고 한다.</li>\n<li>resolve : 정상 수행 후 최종 결과 반환한다. then으로 받아서 원하는 일을 할 수 있다.</li>\n<li>reject : 문제발생시 호출. Error object를 반환한다. catch로 받는다.</li>\n<li>then : 첫 번째 인수는 프로미스 성공시의 결과를, 두 번째 인수는 실패시의 에러를 받는다. 인수를 하나만 전달하면 성공시의 결과만 다룬다.</li>\n<li>catch : 에러가 발생한 경우만 다룬다.</li>\n<li>finally : 성공,실패와 상관없이 무조건 마지막에 호출된다.</li>\n</ul>\n<p>이를 이용해 개발자는 비동기 동작을 동기적으로 다룰 수 있게 되었다. 하지만 프로미스가 완벽한 것은 아니었는데, 이에 대해서는 후술한다.</p>\n<h3 id=\"제네레이터\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0\" aria-label=\"제네레이터 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제네레이터</h3>\n<p>자바스크립트의 제네레이터는 이터러블을 쉽게 만들 수 있도록 도와주는 함수이자, 이터레이터이다.<br>\n제네레이터를 이용해 비동기 동작을 동기적으로 다룰 수 있는데, 필자는 아직 자세하게는 모르고 코어자바스크립트에 소개된 내용에 대해서만 알고 있다. 보다 자세한 활용방법은 유인동님의 함수형 프로그래밍 강의에서 다뤄지고 있다.<br>\n이터러블과 이터레이터, 많이 낯설다. 제네레이터를 이해하기 위해(?) 잠깐만 훑고 지나가겠다. 레퍼런스는 유인동님의 함수형 프로그래밍 강의, 그리고 <a href=\"https://gist.github.com/qodot/ecf8d90ce291196817f8cf6117036997\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">이 글</a>이다.</p>\n<p><strong>이터러블</strong></p>\n<ul>\n<li>이터러블은 <strong>이터레이터 객체를 반환</strong>하는 객체이다.</li>\n<li><code class=\"language-text\">Symbol.iterator</code>는 대표적인 상용 심볼로, 이터러블한 객체를 정의하기 위한 심볼이다. <code class=\"language-text\">@@iterator</code>로 표기할 수도 있다.</li>\n<li>이터러블은 <code class=\"language-text\">Symbol.iterator</code> 심볼을 속성으로 가지고 있고, 이런 스펙을 이터러블 프로토콜 이라고 하고 이 프로토콜을 지킨 객체를 이터러블 객체라고 한다.</li>\n<li>다른 말로는 <code class=\"language-text\">[Symbol.iterator]()</code>를 가진 값이다.</li>\n<li><code class=\"language-text\">Symbol.iterator</code>은 key로 쓰일 수 있는데 <code class=\"language-text\">이터러블[Symbol.iterator]</code>를 콘솔에 찍어보면 함수가 나온다. <strong>이를 실행했을 때 이터레이터를 리턴</strong>한다. 그러니까 대충 아래와 같이 생긴 것이다.\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> iterable <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">,</span> done <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>핵심은 이터러블은, <strong>진행하다가 순회할 수 있다</strong>는 것이다. 어느정도 진행하고, 잠시 중단된 그 부분부터 다시 순회할 수 있다. 이게 가능하려면 이터러블이 반환하는 이터레이터가 <code class=\"language-text\">Symbol.iterator</code>를 가지고 있어야 한다. 이걸 well formed iterator라고 한다. 그리고 그 결과는 이터레이터 자기 자신이다. <code class=\"language-text\">이터레이터[Symbol.iterator]() == 이터레이터 // true</code></li>\n</ul>\n<p><strong>이터레이터</strong></p>\n<ul>\n<li>이터러블의 <code class=\"language-text\">[Symbol.iterator]()</code>로 이터레이터가 만들어진다.</li>\n<li>이터레이터는 <code class=\"language-text\">{value, done}</code> 객체를 리턴하는 <code class=\"language-text\">next()</code> 메소드를 가진 객체이다.</li>\n<li>이런 스펙을 이터레이터 프로토콜이라고 한다.</li>\n<li>next 메소드를 실행하면 <code class=\"language-text\">{value, done}</code>을 리턴한다.</li>\n</ul>\n<p>그러니까 이터러블은 next() 메소드를 구현하고 done과 value 속성을 가진 <strong>객체를 반환하는 객체를 반환하는 객체</strong>인 것이다.</p>\n<p align=\"center\">\n<img src=\"http://file3.instiz.net/data/file3/2019/09/28/c/6/f/c6f268b978bc685dabedfe2fd92609b4.gif\">\n</p>\n<p>이터러블과 이터레이터가 뭔지 얕게나마 훑어보았으니 다시 이 글의 본 목적의 세부항목인 제네레이터로 돌아온다.<br>\n제네레이터는 이렇게 생길 수 있는데,</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">yield</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>저 yield 키워드가 핵심이다. yield는 제네레이터를 <strong>중지하거나 재개하는데</strong> 사용되는 키워드로, 키워드 뒤에 오는 표현식이 반환되고 만약 없다면 undefined가 반환된다. 제네레이터는 이터레이터이자 이터러블을 만들기 때문에 개발자는 yield를 이용해 비동기 동작을 수행한 후 다음 동작을 부르는 등, 원하는 순서에 비동기 동작들을 순서대로 이용할 수 있다.</p>\n<p>이렇게 promise와 제네레이터는 비동기 관련 코드를 위에서 아래로 읽을 수 있게 하는 것은 물론이고 전통적인 해결 방법의 단점들도 해결한다.</p>\n<h3 id=\"async-await\" style=\"position:relative;\"><a href=\"#async-await\" aria-label=\"async await permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>async, await</h3>\n<div align=\"center\">\n<img src=\"https://pics.me.me/es7-promise-async-await-es6-promise-es5-callback-hell-async-27790051.png\">\n</div>\n<p>그러나 promise의 then 체이닝이나, promise를 여러번 중첩해서 사용해야 하는 경우 콜백지옥과 똑같은 문제가 발생하기 때문에 es7에서는 async, await이 추가되었다.</p>\n<ul>\n<li>프로미스를 기반으로 하는 syntax sugar의 일종이다</li>\n<li>then이 <strong>거의</strong> 필요하지 않다</li>\n<li>프로미스를 따로 만들지 않아도 async 키워드가 붙은 함수는 항상 프로미스를 반환한다. 캐치되지 않은 예외가 발생해도 마찬가지이다.</li>\n<li><strong>때문에 async 함수를 호출했을 때의 반환값은 반드시 프로미스이다.</strong></li>\n<li>await은 프로미스의 result값을 얻게 해주는 역할을 하며 aysnc안에서만 사용할 수 있다.</li>\n<li>promise 앞에 await을 붙이면 그 프로미스가 settled될 때까지 기다린다.</li>\n<li>await은 키워드 뒤의 내용을 프로미스로 자동 전환하고 프로미스가 resolved 된 후 다음 코드를 실행하게 한다.</li>\n<li>이를 이용해 함수 내부에서 실질적인 비동기 작업이 필요한 위치마다 await을 표기하여 비동기적 동작들을 동기적으로 핸들링할 수 있다.</li>\n</ul>\n<blockquote>\n<p>await은 이터러블, 제네레이터를 이용한 함수형 프로그래밍과 연관이 있다고 한다.<br>\n자세한 것은 강의를 끝까지 듣게 되면 이 글에 다시 추가하겠다. 우선은 코어자바스크립트 책 내용을 보고 알게된 내용부터 !</p>\n</blockquote>\n<p>🚨<strong>async, await, try-catch를 함께 사용할 때 주의할 점이 있다.</strong></p>\n<p>프로미스가 성공할 때에는 프로미스를 리턴할 때 await을 붙이든 안 붙이든 차이가 없지만, 만약 실패하여 에러 객체를 catch로 다뤄야 하는 경우에는 리턴할 때 await을 붙여야 한다. 왜냐하면 try-catch에서 <code class=\"language-text\">catch(error) {...}</code>는 오직 await 처리된 rejected promise 만을 받기 때문이다. 이에 대한 더 자세한 내용과 데모 코드는 <a href=\"https://dmitripavlutin.com/return-await-promise-javascript/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">이 글</a>에서 확인할 수 있다.</p>","fields":{"slug":"/core-javascript/4/"},"frontmatter":{"title":"코어자바스크립트 - 콜백함수","date":"2021-08-17","lastUpdated":"2021-08-17","description":"코어자바스크립트 스터디 4장","tags":["Javascript","Book"],"thumbnail":null}},"previous":{"fields":{"slug":"/core-javascript/3/"},"frontmatter":{"title":"코어자바스크립트 - this"}},"next":{"fields":{"slug":"/codesoom/1st/"},"frontmatter":{"title":"코드숨 리액트 6기 1주차, 2주차 주간회고"}}},"pageContext":{"id":"345f5448-4536-5fae-ad8e-abe0efa16af1","previousPostId":"581764c7-ca4a-5de6-a397-7fbfdbe5f154","nextPostId":"43032167-888f-5847-9c47-a9688ed3a806"}},"staticQueryHashes":["2260143708","658623446","984448874"]}