{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/client-side-graphql-2/","result":{"data":{"site":{"siteMetadata":{"title":"emewjin.log","siteUrl":"https://emewjin.github.io"}},"markdownRemark":{"id":"ba2a186a-61dc-5bf9-9b11-1ebbd891ceda","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\">들어가며</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A0%95%EC%82%B0-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EC%88%98%EC%A0%95%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\">정산 정보를 수정할 수 있는 컴포넌트</a></p>\n</li>\n<li>\n<p><a href=\"#fragment\">Fragment</a></p>\n<ul>\n<li><a href=\"#fragment-collocation\">Fragment Collocation</a></li>\n<li><a href=\"#fragment-masking\">Fragment Masking</a></li>\n<li><a href=\"#fragment%EC%9D%98-%EC%A4%91%EB%B3%B5\">Fragment의 중복</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#query\">Query</a></p>\n<ul>\n<li><a href=\"#%EC%8A%A4%ED%82%A4%EB%A7%88-%EC%9E%91%EC%84%B1\">스키마 작성</a></li>\n<li><a href=\"#%EB%A6%AC%EC%A1%B8%EB%B2%84-%EC%9E%91%EC%84%B1\">리졸버 작성</a></li>\n<li><a href=\"#usequery%EC%99%80-uselazyquery\">useQuery와 useLazyQuery</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#mutation\">Mutation</a></p>\n<ul>\n<li><a href=\"#%EC%8A%A4%ED%82%A4%EB%A7%88-%EC%9E%91%EC%84%B1-1\">스키마 작성</a></li>\n<li><a href=\"#%EB%A6%AC%EC%A1%B8%EB%B2%84-%EC%9E%91%EC%84%B1-1\">리졸버 작성</a></li>\n<li><a href=\"#usemutation\">useMutation</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#custom-scalar\">Custom Scalar</a></p>\n</li>\n<li>\n<p><a href=\"#field-policy\">Field Policy</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\">마무리</a></p>\n</li>\n</ul>","excerpt":"지난 1부에서는 프론트엔드에서 어드민 페이지를 리액트 앱으로 마이그레이션 할 때 왜 Client Side GraphQL을 선택했고, 환경을 어떻게 구축했는지에 대해 소개했었다. 2부인 이번 글에서는 GraphQL…","html":"<p><a href=\"https://emewjin.github.io/client-side-graphql/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">지난 1부</a>에서는 프론트엔드에서 어드민 페이지를 리액트 앱으로 마이그레이션 할 때 왜 Client Side GraphQL을 선택했고, 환경을 어떻게 구축했는지에 대해 소개했었다.</p>\n<p>2부인 이번 글에서는 GraphQL을 이용해서 실제로 프론트엔드 개발을 어떻게 했는지에 대해 구체적으로 소개하려고 한다. 1부에서 자세하게 다루지 않은 이야기 위주로 작성했다.</p>\n<h2 id=\"들어가며\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\" aria-label=\"들어가며 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가며</h2>\n<p>이 글의 재료는 &#x3C;유저의 정산 정보를 확인하고 수정할 수 있는 모달>을 개발하는 과정이다. 이 기능에 대해 간략하게 소개하면 다음과 같다.</p>\n<ul>\n<li>페이지 진입 시 일부 유저 정보가 row로 제공되는 테이블이 보여짐</li>\n<li>각 row별로 버튼이 존재하고, 버튼을 클릭하면 모달이 열림</li>\n<li>모달 안에서 유저의 정산 정보를 조회하거나 수정할 수 있음</li>\n</ul>\n<h2 id=\"정산-정보를-수정할-수-있는-컴포넌트\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%82%B0-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EC%88%98%EC%A0%95%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\" aria-label=\"정산 정보를 수정할 수 있는 컴포넌트 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정산 정보를 수정할 수 있는 컴포넌트</h2>\n<p>사실 모든 코드를 다 보여주거나 설명하기엔 한계가 있으므로, &#x3C;정산 정보를 수정할 수 있는 컴포넌트>를 중심으로 이야기를 시작해보고자 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">SettlementInfoEditor</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> SettlementInfoEditorProps<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token comment\">// 1. instructor fragment from cache</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> getNormalizedCacheId <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useNormalizedCacheId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">const</span> cachedId <span class=\"token operator\">=</span> <span class=\"token function\">getNormalizedCacheId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> id<span class=\"token operator\">:</span> userId<span class=\"token punctuation\">,</span> typename<span class=\"token operator\">:</span> <span class=\"token string\">'Instructor'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\"></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">const</span> client <span class=\"token operator\">=</span> <span class=\"token function\">useApolloClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\"></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">const</span> instructorFragment <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">readFragment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">    id<span class=\"token operator\">:</span> cachedId<span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">    fragment<span class=\"token operator\">:</span> SettlementInfoEditor_InstructorFragmentDoc<span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token comment\">// 2. contract information fragment</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">const</span> contractInformationFragment <span class=\"token operator\">=</span> <span class=\"token function\">getFragmentData</span><span class=\"token punctuation\">(</span></span><span class=\"gatsby-highlight-code-line\">    SettlementInfoEditor_ContractInformationFragmentDoc<span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">    data</span><span class=\"gatsby-highlight-code-line\">  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>컴포넌트<span class=\"token operator\">...</span><span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><strong>Point 1. 캐시에서 데이터를 꺼내오기</strong>:<br>\n모달을 여는 트리거를 제공하는 테이블은 유저 정보가 있어야 그려질 수 있는데 이미 유저(<code class=\"language-text\">instructor</code>) 정보를 조회하는 쿼리가 페이지의 최상단에 위치해있었다.<br>\n그런데 모달 안에서도 해당 유저 정보 일부가 필요하므로, refetch를 하는 것이 아니라 최상위에서 조회했던 데이터를 캐시에서 꺼내와서 사용했다.</li>\n<li><strong>Point 2. Fragment로 Data Masking하기</strong>:<br>\n모달 안에서만 필요한 데이터를 쿼리할 때, 컴포넌트에서 필요한 데이터를 컴포넌트에서 직접 선언하여 캡슐화한다. 상위 컴포넌트에서는 구체적으로 무슨 데이터가 필요한지 알 필요가 없으며, <code class=\"language-text\">SettlementInfoEditor</code> 컴포넌트가 필요하다고 한 데이터를 Fragment로만 상위에 전달하여 최상위에서 합쳐서 쿼리한다.</li>\n</ul>\n<h2 id=\"fragment\" style=\"position:relative;\"><a href=\"#fragment\" aria-label=\"fragment permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fragment</h2>\n<blockquote>\n<p>Share fields between operations<br>\n<a href=\"https://graphql.org/learn/queries/#fragments\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">A GraphQL fragment</a> is a piece of logic that can be shared between multiple queries and mutations.<br>\n<a href=\"https://www.apollographql.com/docs/react/data/fragments/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">출처</a></p>\n</blockquote>\n<p>Fragment란 스키마의 일부로, 재사용 가능한 단위를 말한다.</p>\n<h3 id=\"fragment-collocation\" style=\"position:relative;\"><a href=\"#fragment-collocation\" aria-label=\"fragment collocation permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fragment Collocation</h3>\n<p>이 프로젝트에서는 (비록 Apollo를 쓰긴 하지만) Relay-style GraphQL을 지향하여 <a href=\"https://emewjin.github.io/relay-style-graphql/#fragment-collocation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Fragment Collocation</a>을 의도했다.</p>\n<blockquote>\n<p>Client Side GraphQL을 선택한 결정적인 이유는 레거시 API를 보다 잘 활용하여 백엔드 리소스를 최소화 하기 위함이지만, 이왕 쓰는거 가장 좋은 방식으로 써보는 연습과 학습을 같이 했다.</p>\n</blockquote>\n<p>Fragment Collocation을 하려는 이유는 어떤 필드가 실제로 쓰이는지 아닌지를 보다 잘 추적하기 위함이다. 프론트엔드 개발을 하다보면 높은 확률로 컴포넌트가 하나의 역할만을 하게 하려고 컴포넌트를 쪼개고, 유지보수하기 쉽게 새 파일로 옮긴다. 한 컴포넌트 내부에 모든 로직이 합쳐져 있을 때에는 그 컴포넌트에서 호출하는 쿼리 속 필드가 어디에 어떻게 쓰이는지 추적하기 쉽지만, 컴포넌트가 분리되면서부턴 어려워진다.</p>\n<p>이 문제를 React의 Props type으로 해결할 수도 있다. 상위 컴포넌트에서 스키마를 작성해 쿼리하고, 하위 컴포넌트에서는 그 데이터를 전달받을 것이므로 자연스럽게 Props에 대한 타입을 정의하고 그것이 곧 쿼리 속 필드가 어떻게 쓰이는지 추적할 수 있는 방법이 된다. 하지만 이 방법엔 문제가 있는데, <a href=\"https://www.apollographql.com/blog/using-graphql-fragments-for-safer-cleaner-and-faster-code#disadvantage-2-duplicating-data-dependencies\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GraphQL의 스키마 정의와 컴포넌트의 Props type을 중복으로 두 벌 작성해야 한다는 점</a>이다.</p>\n<p>이러한 문제까지 해결해줄 수 있는 것이 바로 Fragment Collocation이다.</p>\n<p>위의 코드를 다시 살펴보면 <code class=\"language-text\">SettlementInfoEditor</code>는 컴포넌트 내부에서 <a href=\"https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#fragment-masking\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">코드 제너레이터가 만들어준 Fragment Masking 함수</a> <code class=\"language-text\">getFragmentData</code>를 이용해 데이터를 반환하고, 컴포넌트 내부에선 그 반환값만을 사용하고 있다.</p>\n<p>이렇게 함으로써 <code class=\"language-text\">SettlementInfoEditor</code> 컴포넌트는 내부에서 필요한 필드를 하나하나 Props type에 작성할 필요가 없다. 대신 아래와 같이 (역시 코드 제너레이터가 만들어준) <code class=\"language-text\">FragmentType&lt;T></code> 만 Props type으로 선언해주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">SettlementInfoEditorProps</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">  data<span class=\"token operator\">?</span><span class=\"token operator\">:</span> FragmentType<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typeof</span> SettlementInfoEditor_ContractInformationFragmentDoc<span class=\"token operator\">></span><span class=\"token punctuation\">;</span></span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">SettlementInfoEditor</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  data<span class=\"token punctuation\">,</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> SettlementInfoEditorProps<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">const</span> contractInformationFragment <span class=\"token operator\">=</span> <span class=\"token function\">getFragmentData</span><span class=\"token punctuation\">(</span>\n    SettlementInfoEditor_ContractInformationFragmentDoc<span class=\"token punctuation\">,</span>\n    data\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"fragment-masking\" style=\"position:relative;\"><a href=\"#fragment-masking\" aria-label=\"fragment masking permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fragment Masking</h3>\n<p>코드 제너레이터가 생성해준 <code class=\"language-text\">FragmentType&lt;T></code>를 통해서 최상위에서 쿼리한 데이터에 <code class=\"language-text\">SettlementInfoEditor</code>에서 선언한 <code class=\"language-text\">Fragment</code>의 필드들이 있는지 없는지를 보장받을 수 있고, 타입 지원까지 받을 수 있어 안정적인 코드 작성이 가능해진다.</p>\n<p>또한 <code class=\"language-text\">getFragmentData</code>함수가 <code class=\"language-text\">data</code>로부터 <code class=\"language-text\">Fragment</code>에서 선언한 값으로 타입을 좁혀주기 때문에 <code class=\"language-text\">Fragment</code>에서 선언하지 않은 다른 필드를 사용할 수 없다. 물론, <code class=\"language-text\">data</code> Prop을 직접 이용해 <code class=\"language-text\">Fragment</code> 안에 선언되지 않은 다른 필드에 접근하는 것도 불가능하다. 이를 <strong>Data Masking</strong> 혹은 <strong>Fragment Masking</strong>이라고 한다.</p>\n<p>Fragment를 선언하는 것은 간단하다. (<a href=\"https://emewjin.github.io/client-side-graphql/#%ED%95%9C%EA%B3%84-%EC%A7%84%EC%A7%9C-relay-%EC%8A%A4%ED%83%80%EC%9D%BC%EA%B3%BC-%EB%8B%A4%EB%A5%B8-%EC%A0%90\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">앞서 1부에서 설명했던 것처럼,</a> 컴포넌트 안에 collocation하지는 못했다.) Relay-style을 지향하고자 했기 때문에 이름은 컴포넌트 이름으로 시작하도록 (<del>수동</del>) 컨벤션을 정했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token comment\"># settlementInfoEditor.graphql</span>\n<span class=\"token keyword\">fragment</span> <span class=\"token fragment function\">SettlementInfoEditor_ContractInformation</span> <span class=\"token keyword\">on</span> <span class=\"token class-name\">ContractInformation</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\"># 이런저런 필드들이 선언되어 있다.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"fragment의-중복\" style=\"position:relative;\"><a href=\"#fragment%EC%9D%98-%EC%A4%91%EB%B3%B5\" aria-label=\"fragment의 중복 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fragment의 중복</h3>\n<p>그런가하면 Relay-style이 익숙하지 않을 때 (<del>그렇다고 지금도 익숙한건 아님</del>) Fragment를 사용하다가 Fragment가 필드까지 완벽하게 동일하게 생겼는데 선언하는 주체가 다른 경우, 중복을 감수해야 하는 이유에 대해 궁금증이 생겼다.</p>\n<p>예를 들어 <code class=\"language-text\">SettlementInfoTable</code> 컴포넌트와 <code class=\"language-text\">SettlementInfoEditModal</code> 컴포넌트에서 필요로 하는 데이터가 동일한 상황이었다. 때문에 다음과 같이 서로 다른 두 컴포넌트에서 Fragment가 선언되고 사용되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// SettlementInfoTable.tsx</span>\n<span class=\"token keyword\">const</span> contractInformationFragment <span class=\"token operator\">=</span> <span class=\"token function\">getFragmentData</span><span class=\"token punctuation\">(</span>\n<span class=\"gatsby-highlight-code-line\">  SettlementInfoTable_ContractInformationFragmentDoc<span class=\"token punctuation\">,</span></span>  data\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// SettlementInfoEditModal.tsx</span>\n<span class=\"token keyword\">const</span> contractInformationFragment <span class=\"token operator\">=</span> <span class=\"token function\">getFragmentData</span><span class=\"token punctuation\">(</span>\n<span class=\"gatsby-highlight-code-line\">  SettlementInfoEditor_ContractInformationFragmentDoc<span class=\"token punctuation\">,</span></span>  data\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>각 스키마 선언부를 보면 완벽하게 동일하다. 심지어 두 Fragment에서 선언한 필드는 두 Fragment가 의존하고 있는 <code class=\"language-text\">ContractInformation</code> 타입의 필드와도 빠지는 것 없이 동일하다.</p>\n<p>여기서 궁금했던 것은 “이런 상황에서조차 Fragment를 나누는 이유가 뭘까? 그냥 <code class=\"language-text\">ContractInformation</code>를 재사용 할 수는 없는 걸까?”였다.</p>\n<p>이에 대한 답은,</p>\n<ol>\n<li>\n<p>Relay-style을 지향한다면 아무리 Fragment 선언이 중복되더라도 컴포넌트 간에 절대 Fragment를 공유하지 않아야한다. 그 이유는 다음과 같다.</p>\n<blockquote>\n<p>문제는 여러 컴포넌트에서 GraphQL query들과 fragment들을 공유할 때 발생합니다: 정적분석으로는 <code class=\"language-text\">.graphql</code>파일 안의 어떤 필드가 사용되지 않았는지 알 수 없으므로 <strong>안전하게 제거할 수 없습니다.</strong></p>\n<p>Relay-style Fragment collocation 은 이러한 문제를 해결합니다: 컴포넌트의Fragment에서 필드를 제거하거나 컴포넌트만 제거하고 다른 컴포넌트에서 해당 필드를 참조하지않는 경우, 별도로 해줄 일 없이 쿼리에서 해당 필드가 제거됩니다.</p>\n<p><a href=\"https://emewjin.github.io/relay-style-graphql#%EC%9D%B4%EC%A0%90-1-over-fetching-%EB%B0%A9%EC%A7%80\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">출처</a></p>\n</blockquote>\n</li>\n<li>\n<p>꼭 상위 <code class=\"language-text\">type</code> (여기서는 <code class=\"language-text\">ContractInformation</code>)의 필드 중 일부 만을 사용하는 케이스가 아니더라도, “이 컴포넌트에서 어떤 데이터를 사용할 것”이라고 명시해주는 것만으로도 캡슐화 역할을 할 수 있다는 이점 때문이다.</p>\n</li>\n</ol>\n<p>이렇게 작성한 Fragment를 사용하기 위해서는 최상위 쿼리에서 Fragment를 spread 해야한다.<br>\n다음으로는 그런 schema를 어떻게 작성했는지 살펴보겠다.</p>\n<blockquote>\n<p>Fragment가 어떻게 동작하는지 혹은 다른 장점에 대해서 더 알고싶다면 <a href=\"https://emewjin.github.io/relay-style-graphql/#fragment-collocation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">이 글</a>을 읽어보는 것을 추천한다.</p>\n</blockquote>\n<h2 id=\"query\" style=\"position:relative;\"><a href=\"#query\" aria-label=\"query permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Query</h2>\n<h3 id=\"스키마-작성\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%82%A4%EB%A7%88-%EC%9E%91%EC%84%B1\" aria-label=\"스키마 작성 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스키마 작성</h3>\n<p>데이터를 쿼리하기 위해 먼저 스키마를 작성한다.<br>\n필요한 정보는 <code class=\"language-text\">ContractInformation</code>이므로, 해당 데이터를 불러오는 가장 최상위의 시점의 <code class=\"language-text\">.graphql</code> 파일에 스키마를 작성하고 하위 컴포넌트에서 작성된 Fragment를 spread한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token comment\"># settlementInfoModal.graphql</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Query</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">contractInformation</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">Int</span><span class=\"token operator\">!</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">ContractInformation</span><span class=\"token operator\">!</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">query</span> <span class=\"token definition-query function\">SettlementInfoModal_SettlementInfo</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$id</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">Int</span><span class=\"token operator\">!</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property-query\">contractInformation</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$id</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span><span class=\"token fragment function\">SettlementInfoTable_ContractInformation</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token operator\">...</span><span class=\"token fragment function\">SettlementInfoEditor_ContractInformation</span></span>  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"리졸버-작성\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%A1%B8%EB%B2%84-%EC%9E%91%EC%84%B1\" aria-label=\"리졸버 작성 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리졸버 작성</h3>\n<p>그리고 이 값을 패칭하기 위한 resolver를 작성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// contractInformation.query.ts</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> contractInformationQueryResolvers<span class=\"token operator\">:</span> Partial<span class=\"token operator\">&lt;</span>QueryResolvers<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">contractInformation</span><span class=\"token operator\">:</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> id <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> args<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> apiResponse <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> context<span class=\"token punctuation\">.</span>graphqlFetcherForV1<span class=\"token punctuation\">.</span><span class=\"token generic-function\"><span class=\"token function\">get</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 레거시 API 스펙을 기준으로 작성</span>\n      lecturer<span class=\"token operator\">:</span> ContractInformation<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token constant\">API_ENDPOINT</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>id<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> apiResponse<span class=\"token punctuation\">.</span>lecturer<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"usequery와-uselazyquery\" style=\"position:relative;\"><a href=\"#usequery%EC%99%80-uselazyquery\" aria-label=\"usequery와 uselazyquery permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useQuery와 useLazyQuery</h3>\n<p>이제 Apollo client에서 제공하는 <code class=\"language-text\">useQuery</code>훅을 이용해서 데이터를 패칭하면 되는데, 일반적으로는 다음과 같이 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">query</span> <span class=\"token definition-query function\">InstructorsPage_Instructors</span><span class=\"token punctuation\">(</span>\n  <span class=\"token variable\">$page</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">Int</span>\n  <span class=\"token variable\">$limit</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">Int</span>\n  <span class=\"token variable\">$keyword</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">String</span>\n  <span class=\"token variable\">$searchType</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">InstructorSearchType</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property-query\">instructors</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">page</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$page</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">limit</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$limit</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">keyword</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$keyword</span><span class=\"token punctuation\">,</span> <span class=\"token attr-name\">searchType</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">$searchType</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span><span class=\"token fragment function\">InstructorsTable_InstructorList</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이런 쿼리를 선언했다고 하면, <code class=\"language-text\">useQuery</code> 훅을 호출할 때에는 <code class=\"language-text\">page: $page, limit: $limit, keyword: $keyword, searchType: $searchType</code> 요 친구들을 <code class=\"language-text\">variables</code>에 넘겨주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data<span class=\"token punctuation\">,</span> error <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useQuery</span><span class=\"token punctuation\">(</span>InstructorsPage_InstructorsDocument<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  variables<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그런데 정산 정보를 수정하는 뷰는 모달 내에 그려지고, 모달은 트리거 버튼을 클릭해야만 열린다.</p>\n<p>유저가 버튼을 클릭하지 않았음에도 모달 내에 필요한 데이터를 미리 패칭하여 버튼을 클릭했을 때 모달을 바로 사용할 수 있게 할 수도 있을 것이다. 하지만 이 페이지에서는 트리거 버튼이 테이블의 row만큼 그려지고 있고 <code class=\"language-text\">SettlementInfoModal_SettlementInfo</code> 쿼리를 버튼 컴포넌트 안에서 요청하고 있기 때문에 미리 패칭하게 한다면 페이지에 진입하자마자 버튼의 수만큼 쿼리가 호출될 것이다.</p>\n<p>때문에 <a href=\"https://www.apollographql.com/docs/react/data/queries/#manual-execution-with-uselazyquery\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">lazy query</a>를 사용하여 버튼을 클릭했을 때에만 쿼리를 호출하고, <code class=\"language-text\">loading</code> 값을 이용해 호출 중에는 button을 disabled했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useLazyQuery <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@apollo/client'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> SettlementInfoModal_SettlementInfoDocument <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../../../@types/generated/graphql'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Sample</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>getContractInfo<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> error<span class=\"token punctuation\">,</span> loading <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useLazyQuery</span><span class=\"token punctuation\">(</span></span><span class=\"gatsby-highlight-code-line\">    SettlementInfoModal_SettlementInfoDocument<span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">      notifyOnNetworkStatusChange<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">      variables<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">        id<span class=\"token operator\">:</span> userId<span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token punctuation\">}</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>Button\n      loading<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>loading<span class=\"token punctuation\">}</span>\n      onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// ...</span>\n\n<span class=\"gatsby-highlight-code-line\">        <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getContractInfo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">          variables<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">            id<span class=\"token operator\">:</span> userId<span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>\n        <span class=\"token comment\">// ...</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">></span>\n      정산 정보\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Button</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"mutation\" style=\"position:relative;\"><a href=\"#mutation\" aria-label=\"mutation permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mutation</h2>\n<h3 id=\"스키마-작성-1\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%82%A4%EB%A7%88-%EC%9E%91%EC%84%B1-1\" aria-label=\"스키마 작성 1 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스키마 작성</h3>\n<p>역시 먼저 스키마를 작성해야 한다.<br>\nMutation 요청시 서버에 전송할 데이터인 <code class=\"language-text\">input</code>에 대한 스키마를 다음과 같이 작성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">input</span> <span class=\"token atom-input class-name\">UpdateSettlementInfoInput</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\"># 서버에 전송할 필드들을 선언</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>GraphQL의 mutation은 성공시 성공한 객체 (업데이트된 값)를 내려주는 것이 일반적이라고 한다.\n그러나 레거시 API는 단순하게 <code class=\"language-text\">{ok: boolean}</code> 만을 내려주고 있었다. 즉, 업데이트 된 데이터를 반환하지 않기 때문에 <code class=\"language-text\">null</code>이 맞겠으나 <a href=\"https://github.com/ardatan/graphql-tools/issues/277\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GraphQL에서 <code class=\"language-text\">null</code>은 사용할 수 없다고 한다.</a> 그렇다고 GraphQL의 컨벤션을 따르게 API를 수정하기 어려우므로 대신 Boolean을 리턴 타입으로 작성했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Mutation</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">updateSettlementInfo</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">input</span><span class=\"token punctuation\">:</span> <span class=\"token atom-input class-name\">UpdateSettlementInfoInput</span><span class=\"token operator\">!</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token scalar\">Boolean</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">mutation</span> <span class=\"token definition-mutation function\">SettlementInfoEditModal_UpdateSettlementInfo</span><span class=\"token punctuation\">(</span>\n  <span class=\"token variable variable-input\">$input</span><span class=\"token punctuation\">:</span> <span class=\"token atom-input class-name\">UpdateSettlementInfoInput</span><span class=\"token operator\">!</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property-query property-mutation\">updateSettlementInfo</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">input</span><span class=\"token punctuation\">:</span> <span class=\"token variable variable-input\">$input</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"리졸버-작성-1\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%A1%B8%EB%B2%84-%EC%9E%91%EC%84%B1-1\" aria-label=\"리졸버 작성 1 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리졸버 작성</h3>\n<p>Mutation resolver는 다음과 같이 작성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token keyword\">type</span> <span class=\"token punctuation\">{</span> MutationResolvers <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../../../../@types/generated/resolversTypes'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> settlementInfoMutationResolvers<span class=\"token operator\">:</span> Partial<span class=\"token operator\">&lt;</span>MutationResolvers<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">updateSettlementInfo</span><span class=\"token operator\">:</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> userId<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>newInfo <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> args<span class=\"token punctuation\">.</span>input<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">await</span> context<span class=\"token punctuation\">.</span>graphqlFetcherForV1<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>\n      <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token constant\">API_ENDPOINT</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>userId<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 레거시 API 스펙에 맞게 매핑</span>\n        bank_holder<span class=\"token operator\">:</span> newInfo<span class=\"token punctuation\">.</span>bankHolder<span class=\"token punctuation\">,</span>\n        <span class=\"token operator\">...</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>input값의 <code class=\"language-text\">Maybe</code>에 대해서는 검증할 필요 없다고 합의했다. Mutation resolver에는 검증 완료된 input값이 넘어와야하기 때문이다. resolver에서는 단순히 <code class=\"language-text\">null</code>값만 털어내어 API 요청을 보낸다.</p>\n<p>작성한 resolver는 잊지말고 실행가능한 스키마를 만드는 함수에 등록해준 후, 코드 제너레이터를 실행하자.</p>\n<h3 id=\"usemutation\" style=\"position:relative;\"><a href=\"#usemutation\" aria-label=\"usemutation permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useMutation</h3>\n<p>Mutation 요청을 실제로 보내는 코드를 살펴보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useMutation <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@apollo/client'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>\n  InstructorsPage_InstructorsDocument<span class=\"token punctuation\">,</span>\n  SettlementInfoEditModal_UpdateSettlementInfoDocument<span class=\"token punctuation\">,</span>\n  SettlementInfoModal_SettlementInfoDocument<span class=\"token punctuation\">,</span>\n  UpdateSettlementInfoInput<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../../../@types/generated/graphql'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>updateContractInfo<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> loading<span class=\"token operator\">:</span> mutationLoading <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useMutation</span><span class=\"token punctuation\">(</span>\n  SettlementInfoEditModal_UpdateSettlementInfoDocument<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span>\n    refetchQueries<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n      InstructorsPage_InstructorsDocument<span class=\"token punctuation\">,</span>\n      SettlementInfoModal_SettlementInfoDocument<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">onCompleted</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// do something</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">onError</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>mutationError<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// do something</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Mutation 성공시, 갱신된 데이터를 불러오기 위해 refetch를 진행한다. 사실 GraphQL의 캐싱 이점을 누리려면 무조건 refetch보다 변경된 값에 대해 캐시 데이터를 업데이트해서 Apollo에서 제공하는 “캐시 업데이트 시 리렌더 되는 것”을 활용하는 것이 좋을 것이다.</p>\n<p>하지만 그러려면 mutation에 대한 응답으로 갱신된 데이터를 받아올 수 있어야 하는데, 앞서 말했듯 레거시 API는 그렇지 않기 때문에 이 점을 많이 활용할 수 없었다. 그래도 백엔드 개발자들의 리소스가 되는 선에서 새로 개발해야 했던 API에서는 mutation 성공 시의 데이터를 응답값에 포함해서 내려주었다.</p>\n<blockquote>\n<p>이처럼 GraphQL을 이용하긴 하지만 완벽하게 GraphQL을 이용하고 모든 이점을 누렸다고 볼 수는 없는 프로젝트이다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>updatePoint<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> loading <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useMutation</span><span class=\"token punctuation\">(</span>\n  UserPointModal_UpdateUserPointDocument<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token comment\">/**</span></span><span class=\"gatsby-highlight-code-line\"><span class=\"token comment\">     * mutation 성공 -> 응답에 포함된 업데이트된 값으로 캐시 업데이트</span></span><span class=\"gatsby-highlight-code-line\"><span class=\"token comment\">     */</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token function-variable function\">update</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>cache<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> data <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">      <span class=\"token operator\">...</span></span><span class=\"gatsby-highlight-code-line\">      cache<span class=\"token punctuation\">.</span><span class=\"token function\">updateFragment</span><span class=\"token punctuation\">(</span></span><span class=\"gatsby-highlight-code-line\">        <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">          id<span class=\"token operator\">:</span> <span class=\"token function\">getNormalizedCacheId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> id<span class=\"token operator\">:</span> userId<span class=\"token punctuation\">,</span> typename<span class=\"token operator\">:</span> <span class=\"token string\">'User'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">          fragment<span class=\"token operator\">:</span> UserPointModal_UserFragmentDoc<span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">        <span class=\"token punctuation\">(</span>fragment<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">          <span class=\"token operator\">...</span>fragment<span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">          id<span class=\"token operator\">:</span> userId<span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">          point<span class=\"token operator\">:</span> updatedUserPoint<span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></span><span class=\"gatsby-highlight-code-line\">      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></span>    <span class=\"token operator\">...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"custom-scalar\" style=\"position:relative;\"><a href=\"#custom-scalar\" aria-label=\"custom scalar permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Custom Scalar</h2>\n<p>GraphQL은 스키마 작성시 타입을 Scalar로 작성할 수 있는데, Scalar는 값을 보다 구체적으로 표현해주는 타입이라고 생각하고 있다. 예를 들어 <code class=\"language-text\">email</code>이라는 필드를 <code class=\"language-text\">String</code>으로 표현할 수도 있겠지만 <code class=\"language-text\">Email</code>이라고 표현할 수 있다면 우리가 생각하는 이메일 포맷으로 구체적으로 값을 표현해줄 수 있을 것이다.</p>\n<p>이런 Scalar는 GraphQL에서 기본으로 제공하는 것도 있지만, Custom Scalar라고 해서 직접 선언할 수도 있다. 이 프로젝트에서 쓰는 <a href=\"https://www.apollographql.com/docs/apollo-server/schema/custom-scalars/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Apollo의 공식문서</a>를 따라 Custom Scalar를 선언해보자.</p>\n<p>우리 팀은 Date 객체를 다루는 라이브러리로 dayjs를 쓰고 있는데, 서버에서 전달받은 값을 클라이언트에서 dayjs 인스턴스로 사용하고 반대로 클라이언트에서 보내는 값은 지정된 포맷의 문자열로 변환해서 서버에 전달하고 싶었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> GraphQLScalarType <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'graphql'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> dayjs <span class=\"token keyword\">from</span> <span class=\"token string\">'../utils/date'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// GraphQL을 통한 input output의 타입을 바꿔주는 역할</span>\n<span class=\"token keyword\">const</span> DateTimeScalar <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">GraphQLScalarType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'DateTime'</span><span class=\"token punctuation\">,</span>\n  description<span class=\"token operator\">:</span> <span class=\"token string\">'DateTime for JavaScript Date instance'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">serialize</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> value <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">dayjs</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">parseValue</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">dayjs</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token string\">'YYYY-MM-DD HH:mm:ss'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> scalarResolvers <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  DateTime<span class=\"token operator\">:</span> DateTimeScalar<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>중요한 것은 <code class=\"language-text\">serialize</code>와 <code class=\"language-text\">parseValue</code>이다. 쉽게 말하면 <code class=\"language-text\">serialize</code>는 서버에서 받은 값을 클라이언트 친화적으로 변경하고 <code class=\"language-text\">parseValue</code>는 클라이언트 친화적인 값을 서버가 해석할 수 있는 값으로 변경한다.</p>\n<p>이렇게 만든 Custom Scalar는 resolver에 담아 실행가능한 스키마를 만드는 함수에 넘겨주고</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> schema <span class=\"token operator\">=</span> <span class=\"token function\">makeExecutableSchema</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  typeDefs<span class=\"token operator\">:</span> <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>typeDefs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  resolvers<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n<span class=\"gatsby-highlight-code-line\">    scalarResolvers<span class=\"token punctuation\">,</span></span>    <span class=\"token operator\">...</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>스키마에 scalar를 선언하면 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">scalar</span> <span class=\"token class-name\">DateTime</span></code></pre></div>\n<h2 id=\"field-policy\" style=\"position:relative;\"><a href=\"#field-policy\" aria-label=\"field policy permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Field Policy</h2>\n<p>GraphQL에서 중요한 부분 중 하나가 캐시라고 생각한다. Apollo Client의 캐싱에 대해서는 <a href=\"https://www.apollographql.com/docs/react/caching/overview\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">공식문서</a>를 읽어보는 것이 가장 좋다. 캐싱에서 핵심적인 부분은 정규화(normalization)인데, Apollo는 <code class=\"language-text\">타입이름: 아이디</code>를 유니크한 캐시 ID로 삼아서 데이터를 정규화한다. Apollo의 정규화에 대해서는 <a href=\"https://youtu.be/9G2vT4C4sAY?t=1430\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">DEVIEW 2023 GraphQL 잘 쓰고 계신가요? (Production-ready GraphQL) 발표</a>가 쉽게 설명해주신 것 같다.</p>\n<p><a href=\"https://www.apollographql.com/docs/react/caching/cache-configuration/#typepolicy-fields\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Type Policy</a>에 field policy를 작성하여 아폴로 클라이언트가 <a href=\"https://www.apollographql.com/docs/react/caching/cache-field-behavior\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">특정 필드에 대해 캐시를 어떻게 읽고 쓸 것인지 정의할 수 있다</a>.</p>\n<p>여기서는 argument를 사용하는 필드에 대해 <a href=\"https://www.apollographql.com/docs/react/caching/cache-field-behavior#specifying-key-arguments\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">key argument를 명시</a>하여 쿼리 시 어떤 argument를 기준으로 데이터를 캐싱할 것인지 설정했다. <strong>기본적으로는 모든 argument가 key argument가 되므로,</strong> 만약 캐싱 조건에 필요없는 argument가 있다면 정책을 설정해주는 것이 좋다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> <span class=\"token keyword\">type</span> <span class=\"token punctuation\">{</span> TypedTypePolicies <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./generated/typePolicies-helper'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> typePolicies<span class=\"token operator\">:</span> TypedTypePolicies <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  Query<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    fields<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      instructors<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        keyArgs<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'page'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'limit'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'keyword'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'searchType'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      contractInformation<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        keyArgs<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'id'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>작성한 Type policy는 아폴로 클라이언트를 초기화 할 때 넘겨주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> apolloClient <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ApolloClient</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  defaultOptions<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    mutate<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      fetchPolicy<span class=\"token operator\">:</span> <span class=\"token string\">'no-cache'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"gatsby-highlight-code-line\">  cache<span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InMemoryCache</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">    typePolicies<span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">    possibleTypes<span class=\"token operator\">:</span> fragmentMatcher<span class=\"token punctuation\">.</span>possibleTypes<span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></span>  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"heading-anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<p>여기까지 실질적으로 프로젝트에서 GraphQL을 어떻게 활용했는지 구체적으로 사례들을 살펴보았다. 마지막으로 이 프로젝트를 개발한 것이 몇 달 전이라, 기억이 가물가물하긴 하지만 최대한 기억나는 포인트들을 정리해보았다. 혹시라도 뒤늦게 생각나는 부분들이 있다면 틈틈이 추가 수정해보겠다.</p>\n<p>비록 어드민이긴 하지만 실무에서 GraphQL을 처음 사용해본 프로젝트라는 점에서 인상 깊은 프로젝트였다. 아 그리고 RESTful API를 그대로 사용하기 때문에 over-fetching 문제를 해결한다는 이점은 누리지 못한 건가 싶긴 하지만…? 중복되는 fragment는 알아서 merge해서 한 번의 요청만 보낸다고 하니까 반만 누린 걸로 하자…</p>\n<p>GraphQL을 통해 레거시 API를 다루는 경험이 꽤나 좋았기 때문에 이후로도 레거시 API를 사용해서 새 프론트엔드를 개발해야 한다고 했을 때 “그럼 GraphQL?”을 외치게 되었다. 유저가 더 많고 케이스가 다양한 B2C에도 적용하고 운영했을 때, 인상이 달라질지 어쩔지 궁금하다.</p>","fields":{"slug":"/client-side-graphql-2/"},"frontmatter":{"title":"Client side GraphQL로 어드민 만들기 2부 - 어떻게 개발했는가","date":"2024-01-27","lastUpdated":"2024-01-27","description":"완전하진 않지만 Relay-style을 지향하며 GraphQL로 레거시 API와 함께 새 프론트엔드를 개발한 경험에 대해 기억을 더듬어봤습니다.","tags":["React","GraphQL"]}},"previous":{"fields":{"slug":"/client-side-graphql/"},"frontmatter":{"title":"Client side GraphQL로 어드민 만들기 1부 - 환경 구축"}},"next":null},"pageContext":{"id":"ba2a186a-61dc-5bf9-9b11-1ebbd891ceda","previousPostId":"d3875db3-7419-5faf-ae6b-454b8645ab42","nextPostId":null,"ogImage":"public/og-image/client-side-graphql-2/index.png"}},"staticQueryHashes":["2260143708","984448874"]}